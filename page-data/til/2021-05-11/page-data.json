{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/2021-05-11/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"2cb8fe5a-8d36-5cea-a5c3-130b7b0ef81d","excerpt":"fact 나는 무려 9000번의 슛을 놓쳤고, 약 300게임을 졌다. 나는 살아오면서 계속 실패를 거듭했다. 그것이 내가 성공할 수 있었던 비결이다.(MJ) feelings finding object…","html":"<ol>\n<li>\n<p>fact</p>\n<ul>\n<li>나는 무려 9000번의 슛을 놓쳤고, 약 300게임을 졌다. 나는 살아오면서 계속 실패를 거듭했다. 그것이 내가 성공할 수 있었던 비결이다.(MJ)</li>\n</ul>\n</li>\n<li>feelings</li>\n<li>\n<p>finding</p>\n<ul>\n<li>\n<p>object 6장 메시지와 인터페이스</p>\n<ol>\n<li>책임이 객체가 수신할 수 있는 메시지의 기반이 된다.</li>\n<li>어플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억하라</li>\n<li>객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다.</li>\n<li>협력은 어떤 객쳋가 다른 객체에게 무언가 요청할때 시작되며, 메시지는 객체 사이의 협력을 가능하게 하는 매개체이다.</li>\n<li>협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.</li>\n<li>메시지는 operation name과 argument로 구성되며 메시지 전송은 여기에 메시지 메시지 수신자를 추가한것이다.</li>\n<li>메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 한다.</li>\n<li>전통적인 방식의 개발자는 어떤 코드가 실행될지를 정확하게 알고 있는 상황에서 함수 호출이나 프로시저 구문을 작성한다. 다시말해 코드의 의미가 컴파일 시점과 실행 시점에 동일하다는 것이다. 반면 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.</li>\n<li>실행 시점에 실제로 실행되는 코드는 메시지를 수신하는 객체의 타입에 따라 달라지기 때문에 우리는 그저 메시지에 응답할 수 있는 객체가 존재하고 그 객체가 적절한 메서드를 선택해서 응답할 것이라고 믿을 수 밖에 없다.</li>\n<li>메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있다.</li>\n<li>실행 시간에 수신자의 클래스에 기반해 메시지를 메서드에 바인딩 하는것은 큰 차이이다.</li>\n<li>객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 한다.</li>\n<li>프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 operation이라고 부른다.</li>\n<li>메시지를 수신했을 때 실제로 실행되는 코드는 메서드다.</li>\n<li>operation(또는 메서드)의 이름과 파라미터 목록을 합쳐 시그니처(signature)라고 부른다. 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다. 메서드는 이 시그니처에 구현을 더한것이다.</li>\n<li>시그니처는 오퍼레이션이나 메서드의 명세(identity)를 나타낸것으로, 이름과 인자의 목록을 포함한다. 반환 타입이 포함되지 않는 이유는 묻지말고시켜라와 message 이론을 따르기 때문이다.</li>\n<li>객체의 퍼블릭 인터페이스가 각 객체의 품질(유지보수)을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다고 할 수 있다.</li>\n<li>좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야한다. 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함해야 하고, 추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지 표현한다.</li>\n<li>\n<p>퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법</p>\n<ul>\n<li>\n<p>디미터 법칙</p>\n<ul>\n<li>협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙</li>\n<li>객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.</li>\n<li>낯선자에게 말하지마라. 오직 인접한 이웃하고만 말하라</li>\n<li>\n<p>밑의 조건을 만족하는 대상에게만 메시지를 전송해야함.</p>\n<ol>\n<li>메서드의 인자로 전달된 클래스</li>\n<li>클래스의 인스턴스 변수의 클래스</li>\n</ol>\n</li>\n<li>디미터 법칙을 따르는 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다.</li>\n<li>캡슐화 원칙이 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면 디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.</li>\n<li>디미터를 위반하면 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송하는데 이를 train wreck이라고 부르며, 클래스의 구현이 외부로 노출됐을 때 나타나는 현상이다.</li>\n<li>디미터 법칙을 위반하는 설계는 인터페이스와 구현의 분리 원칙을 위반한다.</li>\n<li>인터페이스 분리 원칙은 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다.[1] 인터페이스 분리 원칙은 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다. 이와 같은 작은 단위들을 역할 인터페이스라고도 부른다.[2] 인터페이스 분리 원칙을 통해 시스템의 내부 의존성을 약화시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있다.</li>\n<li>디미터 법칙은 객체 간의 협력을 설계할 때 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록 제한한다. 묻지 말고 시켜라 원칙은 디미터 법칙을 준수하는 협력을 만들기 위한 스타일을 제시한다.</li>\n<li>디미터 법칙의 위반 여부는 묻는 개상이 객체인지 자료구조인지에 달려있다. 객체는 내부구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋지만 자료 구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.</li>\n</ul>\n</li>\n<li>\n<p>묻지 말고 시켜라</p>\n<ul>\n<li>디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다. 묻지말고 시켜라는 이런 스타일의 메시지를 작성을 장려하는 원칙을 가리키는 용어이다.</li>\n<li>묻지말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.</li>\n<li>객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다. 묻지 말고 시켜라 원칙에 따르도록 메시지를 결정하다 보면 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.</li>\n<li>호출하는 객체는 이웃 객체가 수행하는 역할을 사용해 무엇을 원하는지를 서술해야하고, 호출되는 객체는 어떻게 해야 하는지를 스스로 결정하게 해야한다. 이것은 일반적으로 묻지말고 시켜라 스타일 또는 더 공식적으로 디미터 법칙으로 알려져있다.</li>\n<li>인터페이스는 객체가 어떻게 하는지가 아니라 무엇을 하는지 서술해야한다.</li>\n</ul>\n</li>\n<li>\n<p>의도를 드러내는 인터페이스</p>\n<ul>\n<li>의도란 리시버를 중립적으로 바라본다는 의미이다.</li>\n<li>무엇을 하는지를 드러내도록 메서드의 이름을 짓기 위해선 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다.</li>\n<li>어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 의도를 드러내는 선택자(intention revealing selector)라고 부른다.</li>\n<li>하나의 이름을 인반화 하는 훈련 : 매우 다른 두번째 구현을 상상하고 해당 메서드에 동일한 이름을 붙혀 가장 추상적인 이름을 만들기</li>\n<li>의도를 드러내는 인터페이스 원칙은 객체의 퍼블릭 인터페이스에 어떤 이름이 드러나야 하는지에 대한 지침을 제공함으로써 코드의 목적을 명확하게 커뮤니케이션할 수 있다.</li>\n</ul>\n</li>\n<li>명령-쿼리 분리</li>\n</ul>\n</li>\n<li>정보 은닉 말고도 묻지말고 시켜라 스타일에는 좀 더 미묘한 이점이 있다. 이 스타일은 객체 간의 상호작용을 getter의 체인 속에 암시적으로 두지 않고 좀 더 명시적으로 만들고 이름을 가지도록 강요한다.</li>\n<li>디미터 법칙과 묻지말고 시켜라 스타일은 객체의 퍼블릭 인터페이스를 깔끔하고 유연하게 만들 수 있는 훌륭한 설계 원칙이다.</li>\n<li>\n<p>하지만 설계는 트레이드오프의 산물이며 맹목적으로 추종하면 원칙들이 충돌할때 억지로 끼워맞추게 되어 무질서한 코드가 발생할 수 있다. 그렇기 때문에 상황에 따라 맞는 원칙을 무시할 수 있어야한다.</p>\n<ol>\n<li>\n<p>디미터 법칙은 하나의 도트(.)를 강제하는게 아니다</p>\n<ul>\n<li>IntStream.of(1, 15, 20, 3, 9).filter(x -> x > 10).distinct().count();</li>\n<li>intStream의 내부 구조가 외부로 노출되지 않는다. inputStrea을 다른 intStream으로 변환할 뿐 객체를 둘러싸고 있는 캡슐은 그대로 유지된다.</li>\n<li>기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 저 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.</li>\n<li>이 메서드들은 객체의 내부에 대한 어떤 내용도 묻지 않는다. 그저 객체를 다른 객체로 변환하는 작업을 수행하라고 시킬 뿐이다.</li>\n<li>결국 도트로 인해 객체의 내부구조를 까지 않는다면 문제가 되지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>결합도와 응집도의 충돌</p>\n<ul>\n<li>묻지말고 시켜라와 디미터 법칙을 준수하는 것이 항상 긍정적인 결과만 내지 않는다. 모든 상황에서 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게된다. 결과적으로 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아진다.</li>\n<li>클래스는 하나의 변경원인만 가져야하는데, 서로 상관없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으며 작은 변경으로도 쉽게 무너질 수 있다. 따라서 디미터 법칙과 묻디말고 시켜라 원칙을 무작정 따르면 애플리케이션은 응집도가 낮은 객체로 넘쳐날것이다.(p201 코드 참고).</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>Future Action Plan</p>\n<ul>\n<li>처음에 잠깐 느려도 괜찬으니 내 페이스대로 하자</li>\n<li>내일은 오브젝트 6장을 20페이지 읽는다.</li>\n<li>리액트 page 부분 리팩터링을 진행한다.</li>\n<li>tdd로 배우는 oop 책을 읽는다.</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"2021-05-11 TIL","date":"May 11, 2021"}}},"pageContext":{"slug":"/til/2021-05-11/","previous":{"fields":{"slug":"/til/2021-05-10/"},"frontmatter":{"title":"2021-05-10 TIL","category":"TIL"}},"next":{"fields":{"slug":"/study/하루3분 네트워크5/"},"frontmatter":{"title":"하루 3분 네트워크 스터디 5","category":"study"}}}},"staticQueryHashes":["3128451518","96099027"]}