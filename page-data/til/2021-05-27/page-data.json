{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/2021-05-27/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"057dcaae-95f6-5b50-b61e-73c45107d528","excerpt":"fact 오브젝트 1장 읽기 es6와 객체지향 공부 바닐라 스크립트를 통해 todo만들어보기 오브젝트 1장 용어정리 feelings 여태 TIL이나 정리 하는 글들을 딱딱하게 정리한다는 목표로 작성하곤 했는데, 다른 사람들도 읽고 싶게 작성하고 싶다는 생각이 들었다. 뭔가 막막했는데, 그래도 계획을 세워서 꾸준히 공부해야겠다. 이런 현상이 반복되는것 같다. 안좋게 생각하는… 하지만 요즘 읽고있는 책이 많이 도움이 된다. 오브젝트를 2번 읽고 있는데(물론…","html":"<ol>\n<li>\n<p>fact</p>\n<ul>\n<li>오브젝트 1장 읽기</li>\n<li>es6와 객체지향 공부</li>\n<li>바닐라 스크립트를 통해 todo만들어보기</li>\n<li>오브젝트 1장 용어정리</li>\n</ul>\n</li>\n<li>\n<p>feelings</p>\n<ul>\n<li>여태 TIL이나 정리 하는 글들을 딱딱하게 정리한다는 목표로 작성하곤 했는데, 다른 사람들도 읽고 싶게 작성하고 싶다는 생각이 들었다.</li>\n<li>뭔가 막막했는데, 그래도 계획을 세워서 꾸준히 공부해야겠다. 이런 현상이 반복되는것 같다. 안좋게 생각하는… 하지만 요즘 읽고있는 책이 많이 도움이 된다.</li>\n<li>오브젝트를 2번 읽고 있는데(물론 9장 까지만) 확실히 다시 읽을때 느낌이 다르다. 추론이 가능하다. 용어들을 정리하는 시간을 갖고 훈련하는 시간을 갖고싶다.</li>\n</ul>\n</li>\n<li>\n<p>finding</p>\n<ul>\n<li>ES6에선 클래스 이외에는 function이 나오면 잘못된 것이다. function에 this가 순수한 함수에 필요할까? 그렇지 않다</li>\n<li>인자로 참조가 넘어오는건 어쩔 수 없지만 왠만하면 읽기용으로 사용하자. 왠만하면 레퍼런스로 넘기지 말고 불가피 하다면 read only로만 사용하자. 그러므로써 side effect를 줋일 수 있다.</li>\n<li>참조를 리턴하게 될 경우 참조를 건드는게 아니라 새로운 오브젝트를 만들어서 리턴하자.</li>\n<li>ES6 부터는 객체 해체의 순서가 보장된다. ES6 해쉬맵이었지만, 이제는 링크드 해쉬맵으로 변경되었기 때문이다.</li>\n<li>재귀를 꼬리재귀로 만드는 요령은 연산을 다 인자로 넘겨서 연산을 남지 않게 하면 된다.</li>\n<li>언어 스펙엔 연산자 중에 스택을 쌓지 않는것들이 있는데 js에는 삼항연산자와 and 그리고 or연산자가 있다.</li>\n<li>함수를 값으로 사용하면 실행 중간에 루틴을 만들어 낼 수 있다. 클로저란 런타임중에 루틴을 만들 수 있는 언어에서만 생길 수 있다.</li>\n<li>함수가 문이라면 다른 클래스에 시그니처가 완전 똑같은 함수가 있다고 하더라도 반드시 두클래스에 동일한 함수를 두번 작성해야한다. 하지만 값이라면 그럴필요 없다.</li>\n<li>함수를 문으로 만들어야 하는 언어들의 특성은 지역변수나 글로벌 변수만 쓸 수 있다.</li>\n<li>함수를 값으로 만들 수 있다면, 루틴이 실행중에 태어날 수 있다.</li>\n<li>루틴은 자신이 어떤 플로우에서 만들어졌는지 알고 있다. 그래서 만들어지는 루틴은 자신을 만든 부모 루틴의 플로우를 기억하므로 부모 루틴의 지역변수를 사용할 수 있다. 이것을 자유변수라고 한다.</li>\n<li>만들어지는 루틴에 의해 자유변수가 만들어지면 자유변수가 있던 플로우는 해지되지 못한다.</li>\n<li>es6부터는 블록만 쳐도 스코프가 태어나며, 스코프는 결국 클로저를 만드는 행위이다.</li>\n<li>쉐도윙을 지원하는 언어는 가장 가까이에 있는 클로저를 사용한다는 규칙이 있다.</li>\n<li>쉐도윙은 네임스페이스에서 사용되며, 이 이름이 외부에서 사용될 때 다른 의미로 내부 루틴에서 사용된다는 상황이라면 반드시 쉐도윙을 이용해야한다.</li>\n<li>바깥쪽의 자유변수를 보호하는 가장 확실한 방법, 안에서 바깥쪽 변수를 못건드리게 하기 위해선 쉐도윙이 가장 확실한 방법이다.</li>\n<li>중첩된 클로저가 단계에 상관없이 자유변수를 다 가져올 수 있는 언어에서 바깥 변수를 보호할 수 있는 유일한 방법은 쉐도윙밖에없다.</li>\n<li>코루틴의 아이디어는 문을 멈출 수 있다는 아이디어로 부터 나온것이다.</li>\n<li>js는 코루틴을 지원하기 위해 내가 작성한 모든 문을 레코드라는 객체에 감싸 메모리에 저장한다.</li>\n<li>js에선 코루틴의 구현을 제너레이터를 통해 할 수 있다.</li>\n<li>\n<p>코루틴을 써야하는 이유</p>\n<ul>\n<li>3개의 다른 함수가 있는데 이 세 함수가 어떤 값을 공유해야 하며, 각 함수들이 반환하는 값들이 의존적으로 다른 함수에 사용된다면 먼저 끝난 함수의 리턴값을 다음 함수에 넘겨야한다.</li>\n<li>하지만 공유할게 한개가 아니라 여러개라면 리턴으론 하기가 쉽지 않다.(객체안에 여러 속성을 넣고 반환해도 가능은 함). 하지만 코루틴을 이용하면 지역변수 내에서 상태를 유지하여 코드가 훨씬 간단해진다.</li>\n</ul>\n</li>\n<li>동적 계획법이란 루프의 조건을 결정하는 요인이 안쪽 루프를 돌다가 변할 수 있는 애들을 말한다.</li>\n<li>\n<p>쉬운것 부터 해야하는 이유</p>\n<ol>\n<li>의존성이 낮다.</li>\n<li>독립된 기능일 확률이 높고 이것을 의존하게 짤 수 있다.</li>\n</ol>\n</li>\n<li>좋은 코드를 짜는데는 데이터를 이해하고 재귀적인 로직을 찾아내거나 추상화된 공통점을 찾거나 또는 역할을 이해하는것에 있다.</li>\n<li>화이트리스트란 : 함수의 인자를 필터링해서 안정적인 조건을 만든다던지, 서버에서 내려온 json을 뷰가 소비하기 좋게 바꿔준다던지의 작업을 화이트 리스트라고 한다. 알고리즘으로 바로 돌입하지 말고, 화이트리스트에서 잘 정리후 알고리즘을 작성한다.</li>\n<li>\n<p>추상화</p>\n<ol>\n<li>카테고라이징: 어떤 기준으로 묶어놓은것</li>\n<li>모델링: 기억해야할 것들만 모아놓은것.</li>\n<li>그룹핑: 그냥 집합</li>\n</ol>\n</li>\n<li>객체지향에선 어떤 사물을 있는 그대로 받아들이는게 아니라 추상화를 이해하고 추상화를 이용해 모델링하는 행위이다.</li>\n<li>\n<p>객체지향 프로그래밍을 말하는 두가지 조건</p>\n<ol>\n<li>대체가능성: 자식은 부모로 대체될 수 있다.</li>\n<li>내적 동질성: 부모의 메서드를 오버라이드하고 부모 타입에 넣어 메서드를 실행하더라도 자식에서 구현한 메서드가 불리는것</li>\n</ol>\n</li>\n<li>js도 chaning을 통해 대체 가능성을 지원한다.</li>\n<li>객체간에는 반드시 은닉과 캡슐화가 지켜져야한다.</li>\n<li>객체지향 언어들은 옵셔널하게 정보 은닉을 지원하는 기능을 갖는다. 없다면 제공하는 기능을 통해 숨기던지 아니면 규칙을 정하는 방법을 사용해야한다.</li>\n<li>역할은 권한과 책임을 갖는다. 중요한 것은 역할과 책임을 일치하게 나눌 수 있는가가 핵심이다.</li>\n<li>각 객체 사이에 프로토콜을 적용할건지는 변화율에 따라 결정된다. 변화율이 다르면 넣고 같다면 넣지 않는다. 이유는 프로토콜이 있으나 없으나 변경되면 같이 바뀌어야하기 때문이다.</li>\n<li>객체지향 원리는 인스턴스별로 컨텍스트를 유지한다. 컨텍스트는 인스턴스마다 고유하게 부여된 메모리를 의미한다.</li>\n<li>객체지향은 컨텍스트 변수를 이용하고 함수에선 불가능하니 자유변수를 이용한다. 객체지향의 인스턴스를 만드는 것은 함수형에선 자유변수를 갖는 새로운 함수를 만드는것과 동일하다.</li>\n<li>템플릿메서드를 사용하는 이유는 부모가 많은 서비스를 제공하고, 실제 할일을 hooking하고 있는 자식에게 위임하기 위함이다.</li>\n</ul>\n</li>\n<li>\n<p>Future Action Plan</p>\n<ul>\n<li>일정들에 대한 피드백 어떻게 줄지 생각하기.. 좀 해라 .. 하기로 해놓고 안한다..ㅠㅠ</li>\n<li>내일 면접 가기… 가기 귀찬다…</li>\n<li>어렵다고 포기하지 말자. 어려우니까 공부하고 훈련하는것이다.</li>\n<li>일정을 통해 나에게 작은 포상을 할 수 있는 방법을 생각해보자.</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"2021-05-26 TIL","date":"May 26, 2021"}}},"pageContext":{"slug":"/til/2021-05-27/","previous":{"fields":{"slug":"/til/2021-05-24/"},"frontmatter":{"title":"2021-05-24 TIL","category":"TIL"}},"next":{"fields":{"slug":"/til/2021-05-26/"},"frontmatter":{"title":"2021-05-27 TIL","category":"TIL"}}}},"staticQueryHashes":["3128451518","96099027"]}