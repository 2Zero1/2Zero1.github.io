{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/2021-05-21/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"7600d2ad-de7c-5e58-84ca-05c2cfb6e51d","excerpt":"fact 오브젝트 7장 정리하기 오브젝트 8장 읽기 하루 3분 네트워크 교실 챕터 1 읽기 등 운동 오브젝트 디자인 책을 읽었다. feelings 객체지향은 어렵다.. 그래도 계속 반복해서 읽으니 점점 외워져서 추론을 하면서 읽을 수 있게 되었다. 이전에는 그냥 다 무슨말인지도 몰랏음.. 오브젝트 디자인 책을 읽고 있는데 번역이 정말.. 읽기가 난감한 부분이 있다. 공부할게 아직 많아서 오늘도 TIL을 못쓰고 잘것 같아서 먼저 작성하기로 마음을 먹었다. ㅎㅎ finding object…","html":"<ol>\n<li>\n<p>fact</p>\n<ul>\n<li>오브젝트 7장 정리하기</li>\n<li>오브젝트 8장 읽기</li>\n<li>하루 3분 네트워크 교실 챕터 1 읽기</li>\n<li>등 운동</li>\n<li>오브젝트 디자인 책을 읽었다.</li>\n</ul>\n</li>\n<li>\n<p>feelings</p>\n<ul>\n<li>객체지향은 어렵다.. 그래도 계속 반복해서 읽으니 점점 외워져서 추론을 하면서 읽을 수 있게 되었다. 이전에는 그냥 다 무슨말인지도 몰랏음..</li>\n<li>오브젝트 디자인 책을 읽고 있는데 번역이 정말.. 읽기가 난감한 부분이 있다.</li>\n<li>공부할게 아직 많아서 오늘도 TIL을 못쓰고 잘것 같아서 먼저 작성하기로 마음을 먹었다. ㅎㅎ</li>\n</ul>\n</li>\n<li>\n<p>finding</p>\n<ul>\n<li>\n<p>object 8장 의존성 관리하기</p>\n<ul>\n<li>어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 말하며 의존성 방향은 항상 단방향이다.</li>\n<li>두 요소 사이의 의존성은 의존되는 요소가 변경 될 때 의존하는 요소도 함께 변경될수도 있다는 것을 의미한다.</li>\n<li>\n<p>의존성 전이(transitive dependency)가 의미하는 것은 객체, a->b->c 와 같이 의존성을 가질 때 a가 b를 의존할 경우, 자동적으로 c도 의존하게 된다는 의미이다.</p>\n<ul>\n<li>\n<p>직접 의존성</p>\n<ul>\n<li>한 요소가 다른 요소에 직접 의존하는 경우</li>\n</ul>\n</li>\n<li>\n<p>간접 의존성</p>\n<ul>\n<li>직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>런타임 의존성과 컴파일 의존성</li>\n<li>클래스가 사용될 특정한 문맥에 대해 최소한의 가정만 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 컨텍스트 독립성이라고 한다.</li>\n<li>컨텍스트 독립적이라는 말은 각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 모른다는 의미이다.</li>\n<li>객체들이 협력 하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야한다. 이런 지식들이 객체 사이의 의존성을 낳는다.</li>\n<li>모든 의존성이 나쁜것은 아니며, 객체들의 협력을 가능하게 만드는 매개체라는 관점에서는 바람직한 것이다.</li>\n<li>문제는 의존성의 정도다.</li>\n<li>두 객체 사이의 의존성이 바람직한 약한 결합도와 의존성이 바람직하지 않은 강한 결합도.</li>\n<li>결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.</li>\n<li>추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.</li>\n<li>결합도를 느슨하게 만들기 위해 변수의 타입을 추상클래스나 인터페이스로 선언하는 것만으론 부족하다. 클래스 안에서 구체 클래스에 대한 모든 의존성을 제거해야만 한다.</li>\n<li>생성자나 인터페이스에 의존할 인자를 보여주는 것을 명시적인 의존성이라고 하며, 의존성이 퍼블릭 인터페이스나 생성자에 표시되지 않으면 숨겨진 의존성이라고한다.</li>\n<li>의존성이 명시적이지 않으면 내부 구현을 직접 살펴봐야 하며, 클래스를 다른 컨텍스트에서 재사용 하기 위해 내부 구현을 직접 변경해야한다.</li>\n<li>\n<p>new가 해로운 이유</p>\n<ul>\n<li>new 연산자를 사용하기 위해선 구체 클래스의 이름을 직접 기술해야한다. 따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수밖에 없기 때문에 결합도가 높아진다.</li>\n<li>new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야한다. 따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나 결합도가 높아진다.</li>\n</ul>\n</li>\n<li>new에 대한 해결 방법으로, 인스턴스를 생성하는 오직을 terminal로 최대한 밀어버려 인스턴스를 생성하는 로직과 사용하는 로직을 분리한다.</li>\n<li>사용과 생성의 책임을 분리하고, 의존성을 생성자에 명시하고, 구체 클래스가 아닌 추상 클래스에 의존하게 하믕로써 설계를 유연하게 만들 수 있다.</li>\n<li>유연하고 재사용 가능한 설계는 객체가 어떻게 하는지가 아니라 무어승ㄹ 하는지를 표현하는 클래스들로 구성된다.따라서 클래스의 인스턴스를 생성하는 코드를 보는 것만으로 객체가 어떤 일을 하는지 쉽게 파악가능하다.</li>\n<li>유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어낼 수 있는 설계다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Future Action Plan</p>\n<ul>\n<li>올바른 방향으로 꾸준히 가기. 그리고 짧은 주기로 피드백 하기. 생각해보니 일정들에 어떻게피드백을 줄지 생각해봐야겠다.</li>\n<li>내일 오브젝트 8장을 정리하고, 하루3분 네트워크 1장을 정리한다.</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"2021-05-21 TIL","date":"May 21, 2021"}}},"pageContext":{"slug":"/til/2021-05-21/","previous":{"fields":{"slug":"/study/오브젝트/7장 객체분해/"},"frontmatter":{"title":"오브젝트 7장","category":"OOP"}},"next":{"fields":{"slug":"/study/하루3분 네트워크5/"},"frontmatter":{"title":"하루 3분 네트워크 스터디 5","category":"study"}}}},"staticQueryHashes":["3128451518","96099027"]}