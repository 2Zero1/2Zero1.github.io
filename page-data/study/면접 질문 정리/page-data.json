{"componentChunkName":"component---src-templates-blog-post-js","path":"/study/면접 질문 정리/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"3a6e95f2-501b-5548-b227-c95615f61996","excerpt":"브라우저의 렌더링 과정을 네트워크 지식과 함께 설명하라 브라우저 주소창에 도메인 입력 DNS 서버로 가서 해당 도메인이 있는지 확인. 있으면 ip를 되돌려줌 해당 IP로 요청(이부분은 네트워크 내용이 들어가야함.) 서버로 부터 html 파일을 받아옴. 브라우저는 html 파일을 파싱하여 dom tree로 만듬. 중간에 link 또는 css 또는 로드할게 있으면, 브라우저는 html 파싱을 멈추고 요청을 한 후에 css를 파싱함. 로딩 또는 css 파싱 끝나면 html을 다시 파싱하여 dom…","html":"<ol>\n<li>\n<p>브라우저의 렌더링 과정을 네트워크 지식과 함께 설명하라</p>\n<ol>\n<li>브라우저 주소창에 도메인 입력</li>\n<li>DNS 서버로 가서 해당 도메인이 있는지 확인. 있으면 ip를 되돌려줌</li>\n<li>해당 IP로 요청(이부분은 네트워크 내용이 들어가야함.)</li>\n<li>서버로 부터 html 파일을 받아옴.</li>\n<li>브라우저는 html 파일을 파싱하여 dom tree로 만듬.</li>\n<li>중간에 link 또는 css 또는 로드할게 있으면, 브라우저는 html 파싱을 멈추고 요청을 한 후에 css를 파싱함.</li>\n<li>로딩 또는 css 파싱 끝나면 html을 다시 파싱하여 dom tree 완성.</li>\n<li>완성된 dom 트리와 cssom 트리를 합쳐 render tree를 만든다.</li>\n<li>중간에 js 파일을 만나면 브라우저는 또 html 파싱을 멈추고 js 를 로딩 후 제어 권한을 자바스크립트 엔진에게 넘기고, 자바스크립트 코드 또는 파일을 로드해서 파싱하고 실행.</li>\n</ol>\n</li>\n<li>\n<p>비동기 프로그래밍</p>\n<ol>\n<li>\n<p>동기형 프로그래밍이란 ?</p>\n<ul>\n<li>함수가 실행이 완료되면 return을 받아 사용하는것.</li>\n</ul>\n</li>\n<li>\n<p>비동기형 프로그래밍이란 ?</p>\n<ul>\n<li>함수가 실행이 완료되면 callback이 불리는것.</li>\n</ul>\n</li>\n<li>\n<p>ajax란 무엇인가</p>\n<ul>\n<li>Javascript의 라이브러리로 Asynchronous Javascript and Xml의 약자이다.</li>\n<li>브라우저가 갖고 있는 XMLHttpRequest 객체를 이용해 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드 하는 기법이며 javascript를 사용한 비동기 통신, 클라이언트와 서버간에 xml 데이터를 주고 받는 기술이다.</li>\n<li>자바스크립트를 이용해 비동기적으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식.</li>\n</ul>\n</li>\n<li>\n<p>promise와 callback의 차이점</p>\n<ul>\n<li>둘다 async 처리를 위해 사용되며, callback은 언제 불릴지 모른다는 특징이있다. 그렇기 때문에 동기식처럼 보기 편하게 작성하고 순서를 보장하기 위해선 불가피하게 콜백지옥이 나오게된다. 하지만 promise는 then을 사용하여 실행할 시점을 정할 수 있다는 특징이 있다. 이러한 특징은 콜백을 사용하게 됨으로 발생하는 콜백을 연속적으로 사용되야 하는 문제점을 해결할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>async, await에 대해 설명해 보시오</p>\n<ul>\n<li>promise를 더욱 쉽게 사용할 수 있도록 es2017 문법으로 나왔다.</li>\n<li>promise로 이전 promise의 응답값에 의존하는 promise를 사용하면 generator와 promise를 같이 쓰게되는데 그때 generator와 이를 사용하는 실행기가 필요하다. 하지만 실행기는 단순히 promise 대기를 가정하는 제너레이터만 와도 돌아가는 일반적인 실행기이다. 일반적으로 이 상황을 일반화 시켜 언어에 내장시킨것이 async await이다.</li>\n<li>제너레이터를 만드는데 사용되는 *의 위치에 async를 넣고, yield를 사용하는 부분에 await를 붙혀 사용한다.</li>\n</ul>\n</li>\n<li>\n<p>제너레이터란 ?</p>\n<ul>\n<li>iterator를 사용하는 쪽은 편하지만 공급하는 쪽은 복잡하다. generator는 iterator를 쉽게 만들어 주는 기능을 한다.</li>\n<li>제너레이터 함수를 호출할때마다 이터레이터가 만들어지며 이는 이터러블이기도 하다.</li>\n<li>제너레이터 안에서 yield를 쓸 수 있으며 이터레이터의 next가 반환되는 것 같은 효과를 일으킬 수 있고, 다음 실행의 인자값을 줄 수도 있다.</li>\n<li>함수는 한번 실행되고 끝나는데 제너레이터는 중간에 끊고 나올 수 있는 기능을 한다. 이를 코루틴이라고 한다.</li>\n<li>이터레이터는 스코프를 이용한 자유변수나 인스턴스의 변수로 관리했어야 했는데, 제너레이터는 지역변수 갱신으로 관리해서 훨씬 보기 편해진다.</li>\n</ul>\n</li>\n<li>\n<p>iterator란 ?</p>\n<ul>\n<li>next 키를 갖고, 값으로 인자를 받지 않고 interatorResultObject를 반환하는 함수가 온다.</li>\n<li>IteratorResultObject는 value와 done이라는 키를 갖고 있다.</li>\n<li>이중 done은 계속 반복할 수 있을지 없을지에 따라 불린값을 반환한다.</li>\n</ul>\n</li>\n<li>\n<p>iterable이란 ?</p>\n<ul>\n<li>Symbol.iterator라는 키를 갖고 값으로 인자를 받지 않고 Iterator Object를 반환하는 함수가 온다.</li>\n<li>둘을 나눈 이유는 iterator는 한번 다 까면 루프를 못돌기 때문에, iterable이 iterator를 생성해준다.</li>\n<li>이 둘이 나온 이유는 statement(문) 반복문은 메모리에 남지 않기 때문에 loop를 메모리에 넣고 객체화 시킬 수 있게 해줌. 그래서 반복문이 여러번 있을때 사용할 필요가 없어짐.</li>\n<li>그럼 함수로 하면 되지 않을까 ? 이거에 대한 답변 생각해보기.</li>\n<li>반복을 할지 말지에 대한 내용도 들어 있고, 반복할때마다 뭘 할지도 들어 있다. 이것을 self discription이라 한다.</li>\n<li>반복을 하진 않지만 외부에서 iterator를 반복하기 위해 필요한 조건과 실행을 전부 다 갖고 있으며. for of은 iterator를 위한것.</li>\n<li>iterator 인터페이스를 따르면 destructure, spread, rest 기능을 사용할 수 있다.</li>\n<li>내장 객체중 대표적인 iterator 객체로 배열, string이 있다.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>자바스크립트의 타입</p>\n<ol>\n<li>\n<p>자바스크립트의 원시타입</p>\n<ul>\n<li>string, number, bigint, boolean, undefined, symbol</li>\n<li>겉보기엔 null도 원시값처럼 보이지만 사실 모든 Object, 모든 구조화된 자료형은 프로토 타입 체인에 따라 null의 자손이다.</li>\n<li>원시값은 불변하여 변형할 수 없다.</li>\n<li>원시값 자체와, 원시값을 할당한 변수를 혼동하지 않아야한다. 변수는 새로운 값을 다시 할당할 수 있지만, 이미 생성한 원시 값은 객체, 배열, 함수와 달리 변형할 수 없다. 예로 변수에 영어 string을 넣어놓고 toUpperCase() 함수를  실행한 후 변수를 찍어보면 변하지 않음을 볼 수 있다.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>자바스크립트 hoisting</p>\n<ul>\n<li>함수 안에 있는 선언들을 모두 끌어 올려서 해당 함수 유효 범위의 최상단에 선언하는것을 말한다.</li>\n<li>자바스크립트는 parser가 함수 실행 전 해당 함수를 한번 훑고 함수 안에 존재하는 변수/함수선언에 대한 정보를 기억하고 있다가 실행 시킨다.</li>\n<li>유효 범위는 함수 블록 안에서 유효하다.</li>\n<li>호이스팅 대상으로 var변수와 함수 선언이 있으며 할당은 끌어올려지지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>clusure</p>\n<ul>\n<li>함수가 만들어지는 시점에 블록 밖의 변수를 캡처하는 기능이 있는데 이를 지역 변수처럼 쓸 수 있다. 하지만 지역변수도 인자도 아니며 이것을 자유변수라고 한다. 자유변수가 사용되는 갖혀진 공간을 클로저라고 한다.</li>\n</ul>\n</li>\n<li>가비지 컬렉터의 역할과 동작 방법</li>\n<li>순환참조란? 해결방법</li>\n<li>자바스크립트의 배열이 실제 자료구조 배열이 아니다?</li>\n<li>이벤트 루프에 대해 설명, 동시성 모델에 대해 설명</li>\n<li>프로토 타입이란?</li>\n<li>\n<p>this</p>\n<ol>\n<li>\n<p>자바스크립트에서 this는 몇가지로 추론되는지</p>\n<ul>\n<li>자바스크립트의 내부 함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든지 this는 전역 객체를 가르킨다. 일반 함수의 this는 window를 가르키며, 화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다.</li>\n</ul>\n</li>\n<li>\n<p>call, apply, bind 함수의 차이(다 찾아보기.)</p>\n<ul>\n<li>this를 바인딩하기 위한 방법이다.</li>\n<li>call은 this 바인딩 하면서 함수를 호출한다. 두번쨰 인자를 apply와 다르게 하나씩 넘긴다.</li>\n<li>apply는 this를 바인딩 하면서 함수를 호출한다. 두번쨰 인자가 배열이다.</li>\n<li>bind는 함수를 호출하는 것이 아닌 this가 바인딩된 새로운 함수를 리턴한다.</li>\n</ul>\n</li>\n<li>use strict모드란</li>\n</ol>\n</li>\n<li>\n<p>프런트엔드 빌드 시스템</p>\n<ol>\n<li>\n<p>바벨이란</p>\n<ul>\n<li>transpiler로 최신 js를 브라우저들이 지원하지 않는 경우가 있어서 지원할 수 있는 이전 버전의 js 코드로 변경해주는 것.</li>\n</ul>\n</li>\n<li>\n<p>폴리필이란</p>\n<ul>\n<li>폴리필(polyfill)은 웹 개발에서 기능을 지원하지 않는 웹 브라우저 상의 기능을 구현하는 코드를 뜻한다.</li>\n<li>기능을 지원하지 않는 웹 브라우저에서 원하는 기능을 구현할 수 있으나, 폴리필 플러그인 로드 때문에 시간과 트래픽이 늘어나고, 브라우저별 기능을 추가하는 것 때문에 코드가 매우 길어지고, 성능이 많이 저하된다는 단점이 있다.</li>\n</ul>\n</li>\n<li>\n<p>eslint란</p>\n<ul>\n<li>코딩 스타일 가이드를 따르지 않거나 문제가 있는 코드나 안티 패턴을 찾기 위해 사용하는 것.</li>\n<li>코딩 컨벤션에 위배되는 코드나 안티 패턴을 자동 검출 해주므로 좋다.</li>\n</ul>\n</li>\n<li>prettier란</li>\n<li>웹 태스크 매니저란?</li>\n</ol>\n</li>\n<li>\n<p>웹팩이란?</p>\n<ul>\n<li>최신 프런트엔드 프레임워크에서 가장 많이 사용되는 모듈 번들러.</li>\n<li>\n<p>기능</p>\n<ol>\n<li>모듈화 문제 해결(여러 js 파일을 import할때 변수 유효 범위 문제)</li>\n<li>웹 개발 작업 자동화(html, css, js, 이미지, css전 처리기 변환 등)</li>\n<li>dynamic loding &#x26; lazy loading을 지원하여 웹 반응속도를 향상시켜줌.</li>\n<li>웹에 어플리케이션에 필요한 위의 모듈들을 하나의 번들로 만들어서 브라우저별 http 요청 숫자의 제약을 피할 수 있음.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>모듈 번들러란?</p>\n<ul>\n<li>웹 어플을 구성하는 자원 (HTML, CSS, js, images 등)을 모두 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만들어주는 도구.</li>\n</ul>\n</li>\n<li>\n<p>cos란? cors를 해결하기 위한 방법은 ?</p>\n<ul>\n<li>Cross-Origin Resource Sharing으로 웹 페이지 상의 제한된 리소스를 최초 자원이 서비스된 도메인 밖의 다른 도메인으로부터 요청할 수 있게 허용하는 구조이다.</li>\n</ul>\n</li>\n<li>\n<p>restAPI란 ?</p>\n<ul>\n<li>Representational state transder는 월드 와이드 웹과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식이다.</li>\n<li>rest는 네트워크 아키텍처 원리의 모음이다.</li>\n<li>네트워크 아키텍처 원리란 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반을 일컫는다.</li>\n<li>\n<p>조건 6가지</p>\n<ol>\n<li>클라이언트/서버 : client와 server가 통신하는 클라이언트/서버의 아키텍처 스타일을 채용</li>\n<li>stateless server : 클라이언트의 앱 상태를 서버에서 관리하지 않는다.</li>\n<li>cache : 리소스의 신선도에 기초해, 한번 가져온 리소스를 클라이언트 쪽에서 돌려쓰는 방식.캐시의 장점은 서버와 클라이언트 사이의 통신량을 줄여 네트워크 대역의 이용과 처리시간을 축소하고 더욱 효율적으로 처리한다.</li>\n<li>uniform interface : URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 의미한다. 인터페이스의 유연성에 제약을 가함으로써 전제적인 아키텍처가 간결해진다.</li>\n<li>layered(계층화) : 시스템을 몇개의 계층으로 분리하는 아키텍처 스타일을 계층화 시스템이라고 한다. 클라이언트 측에서 보면 서버나 프록시 모두 동일한 인터페이스로 접속할 수 있어서 중간에 뭐가 있든 신경쓰지 않는다.</li>\n<li>code on demand: 프로그램 코드를 서버에서 다운받아 클라이언트에서 실행하는 아키텍처 스타일. 장점으로 클라이언트를 차후에 확장할 수 있다는 것이다.</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"면접 질문","date":"December 04, 2019"}}},"pageContext":{"slug":"/study/면접 질문 정리/","previous":{"fields":{"slug":"/study/자료구조 특징/"},"frontmatter":{"title":"자료구조 특징","category":"자료구조"}},"next":{"fields":{"slug":"/til/2019-12-04/"},"frontmatter":{"title":"2019-12-04 TIL","category":"TIL"}}}},"staticQueryHashes":["3128451518","96099027"]}