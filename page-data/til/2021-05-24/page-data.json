{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/2021-05-24/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"d2234640-049c-549b-b7e7-d6380bfe4a28","excerpt":"fact 오브젝트 9장 읽기 버블, 삽입, 퀵 정렬 복습 feelings 여태 TIL이나 정리 하는 글들을 딱딱하게 정리한다는 목표로 작성하곤 했는데, 다른 사람들도 읽고 싶게 작성하고 싶다는 생각이 들었다. 뭔가 막막했는데, 그래도 계획을 세워서 꾸준히 공부해야겠다. 이런 현상이 반복되는것 같다. 안좋게 생각하는… 하지만 요즘 읽고있는 책이 많이 도움이 된다. 오브젝트를 2번 읽고 있는데(물론…","html":"<ol>\n<li>\n<p>fact</p>\n<ul>\n<li>오브젝트 9장 읽기</li>\n<li>버블, 삽입, 퀵 정렬 복습</li>\n</ul>\n</li>\n<li>\n<p>feelings</p>\n<ul>\n<li>여태 TIL이나 정리 하는 글들을 딱딱하게 정리한다는 목표로 작성하곤 했는데, 다른 사람들도 읽고 싶게 작성하고 싶다는 생각이 들었다.</li>\n<li>뭔가 막막했는데, 그래도 계획을 세워서 꾸준히 공부해야겠다. 이런 현상이 반복되는것 같다. 안좋게 생각하는… 하지만 요즘 읽고있는 책이 많이 도움이 된다.</li>\n<li>오브젝트를 2번 읽고 있는데(물론 9장 까지만) 확실히 다시 읽을때 느낌이 다르다. 추론이 가능하다. 용어들을 정리하는 시간을 갖고 훈련하는 시간을 갖고싶다.</li>\n</ul>\n</li>\n<li>\n<p>finding</p>\n<ul>\n<li>\n<p>object 9장</p>\n<ol>\n<li>\n<p>OOP(Open-Closed Principle)</p>\n<ul>\n<li>\n<p>확장과 수정이란?</p>\n<ol>\n<li>확장에 대해 열려있다는 말은 어플의 요구사항이 변경될 떄 이 변경에 맞게 새로운 ‘동작’을 추가해서 어플의 기능을 확장할 수 있다.</li>\n<li>수정에 대해 닫혀있다는 말은 기존의 코드를 수정하지 않고 어플의 동작을 추가하거나 변경할 수 있다.</li>\n</ol>\n</li>\n<li>런타임 의존성과 컴파일 타임 의존성에 관한 이야기이다.</li>\n<li>OOP의 핵심은 추상화에 의존하는것이다.</li>\n</ul>\n</li>\n<li>\n<p>생성 사용 분리</p>\n<ul>\n<li>객체를 생성이 문제가 아니라, 부적절한 곳에서 객체를 생성한다는 것이 문제다. 다시말해 동일한 클래스 안에서 객체 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 공종하는 것이 문제다.</li>\n<li>생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 FACTORY라고 한다.</li>\n<li>FACTORY를 사용하면 client에는 사용과 관련된 책임만 남게 되는데 하나는 FACTORY를 통해 생성된 Movie 객체를 얻기 위한 것이고 다른 하나는 FACTORY를 통해 얻은 객체로 메시지를 보내는 것이다.</li>\n</ul>\n</li>\n<li>\n<p>pure fabrication</p>\n<ul>\n<li>FACTORY를 추가한 이유는 전체적으로 결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에 해당돼 있던 객체 생성 책임을 도메인 개념과는 아무런 상관이 없는 가공의 객체로 이동 시키기 위함이다.</li>\n<li>종종 도메인 개념을 표현하는 객체(정보를 가장 많이 알고 있는 Information expert)에게 책임을 할당하는 것으로 부족한 경우가 있다. 도메인에 모든 책임을 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 문제가 발생할 수 있다.</li>\n<li>책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체를 PURE FABRICATION이라고 한다.</li>\n</ul>\n</li>\n<li>\n<p>dependency injection</p>\n<ul>\n<li>사용하는 객체가 아닌 외부의 독립적인 개체가 인스턴스를 생성한 후 이를 전달해 의존성을 해결하는 방법이다.</li>\n<li>\n<p>주입 방법</p>\n<ol>\n<li>생성자 주입: 객체가 올바른 상태로 생성되는데 필요한 의존성을 명확하게 표현할 수 있음.</li>\n<li>setter 주입: 런타임에 의존성의 대상을 바꿀 수 있지만, 객체가 올바로 생성되기 위해 어떤 의존성이 필수적인지 명시적으로 표현할 수 없다.</li>\n<li>메서드 주입: 주입된 의존성이 한두개의 메서드에서만 사용될 경우 사용됨</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>숨겨진 의존성 보다 명시적인 의존성이 좋다.</p>\n<ul>\n<li>\n<p>숨겨진 의존성</p>\n<ul>\n<li>service locator 패턴 : 의존성을 해결할 객체들을 보관하는 일종의 저장소로 객체가 직접 service locator에게 의존성을 해결할것을 요청한다.</li>\n<li>위의 패턴을 사용하면, 암시적인 의존성이 발생한다.</li>\n<li>암시적 의존성이 안좋은 이유는 문제점을 발견할 수 있는 시점을 코드 작성이 아닌 실행 시점으로 미루기 때문이다.</li>\n<li>숨겨진 의존성의 문제는 의존성을 이해하기 위해 내부 구현을 까야한다.</li>\n<li>숨겨진 의존성은 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어뜨려 놓는다.</li>\n</ul>\n</li>\n<li>\n<p>명시적인 의존성</p>\n<ul>\n<li>DI는 필요한 의존성이 클래스의 퍼블릭 인터페이스에 명시적으로 드러난다.</li>\n<li>의존성을 이해하기 위해 코드 내부를 깔 필요가 없어 캡슐화가 깨지지 않는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>의존성 역전 원칙</p>\n<ul>\n<li>재사용 하려는 대상은 상위 수준의 클래스이며, 상위 수준의 클래스가 하위 수준의 클래스에 의존하면 상위 수준의 클래스를 재사용 할 때 하위 수준의 클래스도 필요해져 사용하기 어려워진다.</li>\n<li>위의 문제를 해결하기 위해 추상화를 이용하며, 상위수준의 클래스와 하위 수준의 클래스가 모두 추상화에 의존하게 한다.</li>\n<li>\n<p>Dependency Inversion Principle(DIP)</p>\n<ol>\n<li>상위 수준의 모듈은 하위 수준의 모듈에 의존해선 안된다. 둘 모두 추상화에 의존해야한다.</li>\n<li>추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야한다.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>패키지와 의존성 역전 원칙</p>\n<ul>\n<li>추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야한다.</li>\n<li>재사용될 필요가 없는 패키지들은 별도의 독립적인 패키지에 모아야한다.</li>\n</ul>\n</li>\n<li>\n<p>유연한 설계는 유연성이 필요할 때만 옳다.</p>\n<ul>\n<li>설계의 미덕은 단순함과 명확함으로 부터 나온다.</li>\n<li>유연한 설계는 복잡한 설계라는 뜻이다.</li>\n<li>유연하고 재사용 가능한 설계가 항상 좋은것은 아니다.</li>\n</ul>\n</li>\n<li>\n<p>핵심은 협력과 책임이다.</p>\n<ul>\n<li>중요한 비즈니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것보다 우선이다.</li>\n<li>객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 마지막 시점에 결정하는것이 좋다. 맹대표님이 말씀 하시기론 생성을 모두 terminal로 최대한 밀어내라고 하셨다.</li>\n<li>의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야하기 때문이다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>Future Action Plan</p>\n<ul>\n<li>일정들에 대한 피드백 어떻게 줄지 생각하기</li>\n<li>내일 면접 가기… 가기 귀찬다…</li>\n<li>해시테이블과 힙 공부하기</li>\n<li>es6강의 끝내기</li>\n<li>es6 함수로 들어가기</li>\n<li>오늘의 나보다 너 나은 사람이 된다.</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"2021-05-21 TIL","date":"May 21, 2021"}}},"pageContext":{"slug":"/til/2021-05-24/","previous":{"fields":{"slug":"/study/오브젝트/7장 객체분해/"},"frontmatter":{"title":"오브젝트 7장","category":"OOP"}},"next":{"fields":{"slug":"/til/2021-05-21/"},"frontmatter":{"title":"2021-05-21 TIL","category":"TIL"}}}},"staticQueryHashes":["3128451518","96099027"]}