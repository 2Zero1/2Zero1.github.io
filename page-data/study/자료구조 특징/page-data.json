{"componentChunkName":"component---src-templates-blog-post-js","path":"/study/자료구조 특징/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"252a3644-6e40-5014-af20-7e0ee5f95b29","excerpt":"c언어로 작성된 프로그램은 세가기 종류의 영역을 가진다. 전역변수나 정적 변수등이 저장되는 static memory 지역 변수가 저장되는 automatic memory free store static memory는 프로그램이 실행하면서 프로그램에서 사용될 전역 변수/정적 변수를 메모리에 할당한 후 프로그램이 종료될 때 해제하는 영역이다. 자동 메모리는 스택 구조로 이루어져 있어 이곳에 저장된 변수는 코드 블록이 종료됨에 따라 메모리에서 없어진다.\nfree store는 automatic memory…","html":"<p>c언어로 작성된 프로그램은 세가기 종류의 영역을 가진다.</p>\n<ol>\n<li>전역변수나 정적 변수등이 저장되는 static memory</li>\n<li>지역 변수가 저장되는 automatic memory</li>\n<li>free store</li>\n</ol>\n<p>static memory는 프로그램이 실행하면서 프로그램에서 사용될 전역 변수/정적 변수를 메모리에 할당한 후 프로그램이 종료될 때 해제하는 영역이다.</p>\n<p>자동 메모리는 스택 구조로 이루어져 있어 이곳에 저장된 변수는 코드 블록이 종료됨에 따라 메모리에서 없어진다.\nfree store는 automatic memory와 달리 프로그래머가 직접 메모리를 관리하는 메모리 영역이다. 그래서 자유롭게 메모리를 할당해서 사용할 수 있지만 그 메모리를 안전하게 해제해야한다.</p>\n<p>Token\n텍스트 분석에서의 토큰은 ‘최소 단위의 기호 또는 단어’를 말한다.</p>\n<h2 id=\"list리스트\" style=\"position:relative;\"><a href=\"#list%EB%A6%AC%EC%8A%A4%ED%8A%B8\" aria-label=\"list리스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>List(리스트)</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 배열처럼 데이터 집합을 보관하는 기능을 가지면서도 한편으로는 배열과는 달리 유연하게 크기를 바꿀 수 있는 자료구조이다.\n- 노드의 생성/소멸, 추가, 삭제, 삽입은 링크드 리스트 자료구조를 구축하기 위한 연산이고, 리스트 탐색은 구축되어 있는 링크드 리스트의 데이터를 활용하기 위한 연산이다.\n- pros&amp;cons\n  - pros\n    1. 새로운 노드의 추가/삽입/삭제가 쉽고 빠르다.(삭제 또는 삽입을 하기 위해선 최대 n번의 계산이 필요한데?)\n  - cons\n    1. 다음 노드를 가리키려는 포인터 때문에 각 노드마다 4byte의 메모리가 추가로 필요하다.\n    2. 특정 위치에 있는 노드를 얻는데 비용이 크며 속도도 느리다.(탐색). 노드의 개수가 n이라면 최악의 경우 n회의 노드 탐색 루프를 실행해야 특정 위치에 있는 노드를 찾을 수 있다.\n\n- 따라서 링크드 리스트가 사용되기에 적합한 곳은 레코드의 추가/삽입/삭제가 잦고 조회는 드문곳이다.\n- doubly linked list\n  - 위의 singly linked list의 탐색 기능을 개선한 자료구조이다.\n  - head와 tail을 알고 있어 양방향 탐색이 가능하다. 그래서 맨 마지막에 있는 데이터를 처음부터 찾을 필요가 없다.\n- 환형 링크드 리스트\n  - 테일의 다음 노드 포인터가 헤드를 가리키고 헤드의 이전 노드가 테일을 가리키게 하는 리스트(doubly linked list일 경우)\n  - 테일에 접근하는 비용이 거의 없는것이나 다름 없을 정도로 작아져 리스트의 마지막에 넣는 함수인 append 성능을 개선시킬 수 있고, 뒤에서부터 노드를 찾아 나가는 노드 탐색 루틴을 구현할 수도 있다.</code></pre></div>\n<h2 id=\"stack\" style=\"position:relative;\"><a href=\"#stack\" aria-label=\"stack permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>stack</h2>\n<ul>\n<li>First In, Last Out</li>\n<li>\n<p>오퍼레이션 종류</p>\n<ol>\n<li>push</li>\n<li>pop</li>\n</ol>\n</li>\n<li>\n<p>종류</p>\n<ol>\n<li>배열을 이용한 스택</li>\n<li>공적으로 스택의 용량을 조절하기 어렵지만 구현이 간단하다.</li>\n<li>리스트를 이용한 스택</li>\n<li>스택의 용량에 제한을 두지 않아도 된다.</li>\n</ol>\n</li>\n<li>\n<p>사용 예</p>\n<ol>\n<li>reverse polish Notation</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"queue\" style=\"position:relative;\"><a href=\"#queue\" aria-label=\"queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>queue</h2>\n<ul>\n<li>queue는 데이터 입력이 폭주할때 먼저 입력 받은 데이터의 처리가 끝나지 않았는데 그 뒤에 새로운 데이터가 마구 입력되면 그 데이터들은 보관할 장소가 따로 없으므로 버려야 한다. 이럴때 밀려드는 데이터를 보관할 장소로 큐가 필요하다.</li>\n<li>buffer와 비슷하다.</li>\n<li>First In First Out 의 특징을 갖고 있다.</li>\n<li>\n<p>순환큐</p>\n<ul>\n<li>큐를 배열로 구현하면 dequeue를 할 경우 맨 앞의 빈자리를 채우기 위해 뒤의 요소들을 모두 옮겨야 되는 문제가 발생한다. 그래서 전단을 가리키는 변수를 도입해서, 배열 내의 요소를 옮기는 대신 변경된 전단의 위치만 관리한다. 또 후단을 가리키는 변수도 도입해서 삽입이 일어날 때마다 변경되는 후단의 위치를 관리한다.</li>\n<li>하지만 위에서 말한 큐 또한 몇번의 dequeue로 전단과 후단이 가까워지고 후단이 들어갈 공간이 몇개 남지 않은 경우, 후단이 배열의 앞에서 다시 시작하도록 만들 수 있다.</li>\n<li>여기까지 한 것으론 순환큐가 가득차있는 상태와 빈 상태를 구분할 수 없다. 둘다 같은 요소를 가리킬 것이기 때문이다. 필요한 배열 요소 개수 + 1 개를 만들어 놓고 후단이 실제 후단에 1을 더한 값을 가지게 한다.</li>\n<li>그래서 큐가 비어있을땐 전단과 후단이 같은곳을 가리키고, 큐가 차있을땐 후단이 전단보다 -1 작은 값을 갖게 된다.</li>\n</ul>\n</li>\n<li>\n<p>링크드 큐</p>\n<ul>\n<li>순환큐는 개념도 복잡하고, 구현도 쉽지 않다.</li>\n<li>링크드 큐는 비교적 단순하다. 하지만 성능은 순환큐가 빠르다. 노드를 생성하고 삭제하기 위해 malloc()을 호추할 필요가 없기 때문이다.</li>\n<li>큐의 크기가 예측가능하고 고성능이 필요한 버퍼와 같은 사례에서는 링크드 큐보다는 순환 큐가 더 적절하다.</li>\n<li>링크드 큐는 가득차있는 상태인지 확인할 필요가 없다.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"자료구조 특징","date":"December 04, 2019"}}},"pageContext":{"slug":"/study/자료구조 특징/","previous":{"fields":{"slug":"/til/2019-11-29/"},"frontmatter":{"title":"2019-11-29 TIL","category":"TIL"}},"next":{"fields":{"slug":"/study/면접 질문 정리/"},"frontmatter":{"title":"면접 질문","category":"면접 질문"}}}},"staticQueryHashes":["3128451518","96099027"]}