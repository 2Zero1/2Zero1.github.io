{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"e53d2a12-436a-5588-9f5a-b9e4254e82d7","excerpt":"1. 코루틴 우리가 비동기 non-blocking으로 짜지 못하는 가장 큰 이유는 예측이 불가능하기 때문이다. 일반적으로 우리가 사용하는 sync-blocking(싱글 스레드 콜백) 방법 밑의 코드와 같이 함수를 선언하고, main 에서 함수를 사용하는 경우는 함수가 어디서 반환될지 우리는 예측이 가능하다. 하지만 콜백으로 짠다면 동작을 예측을 할수가 없다. 밑의 코드를 보면 현재 object의 속성 count를 1씩 증가하는 코드를 작성하고 있다. 하지만 count가 2가 되는 시점에 async…","html":"<h4 id=\"1-코루틴\"><a href=\"#1-%EC%BD%94%EB%A3%A8%ED%8B%B4\" aria-label=\"1 코루틴 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 코루틴</h4>\n<ul>\n<li>우리가 비동기 non-blocking으로 짜지 못하는 가장 큰 이유는 예측이 불가능하기 때문이다.</li>\n<li>일반적으로 우리가 사용하는 sync-blocking(싱글 스레드 콜백) 방법 밑의 코드와 같이 함수를 선언하고, main 에서 함수를 사용하는 경우는 함수가 어디서 반환될지 우리는 예측이 가능하다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">runFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"함수 실행\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"메인을 실행한다.\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">runFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"메인을 종료한다.\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>하지만 콜백으로 짠다면 동작을 예측을 할수가 없다. 밑의 코드를 보면 현재 object의 속성 count를 1씩 증가하는 코드를 작성하고 있다. 하지만 count가 2가 되는 시점에 async-nonblocking 함수(스레드를 새로 생성하여 메인 스레드를 멈추지 않고 1초 홀딩 후에 직접 2를 넣어주는 함수)로 직접 2를 넣어주었다. 우리가 기대한 결과값은 1,2,3,4 순서대로 나오는 것을 기대했지만, 1,2,3,2라는 결과값을 받았다. 멀티스레드 콜백(비동기 논블로킹) 방식은 예측하기가 힘들어진다. 그러다 보니 우리는 위와같이 싱글스레드 콜백 방식으로 코드를 작성한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">async_nonblocking_fun</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>callback <span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">addCount</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    object<span class=\"token punctuation\">[</span><span class=\"token string\">'count'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> object<span class=\"token punctuation\">[</span><span class=\"token string\">'count'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">[</span><span class=\"token string\">'count'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">inputTwo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    object<span class=\"token punctuation\">[</span><span class=\"token string\">'count'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">[</span><span class=\"token string\">'count'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">addCount</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">async_nonblocking_fun</span><span class=\"token punctuation\">(</span>inputTwo<span class=\"token punctuation\">,</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">addCount</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">addCount</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>그래서 자바의 future는 async blocking 방식이다. 자바의 future을 사용할 경우, 멀티 스레드를 생성하여 완료되면 callback을 호출하지만, 실제로 제어권이 main으로 넘어오지 않고, blocking을 하게된다. 그러면 사실상 싱글스레드를 사용하는 것과 마찬가지이다..</p>\n</li>\n<li>\n<p>위의 문제점을 해결하기 위하여 콜백이 호출되는 시점을 우리가 원하는 시점에 제어하는 방법을 사용한다.</p>\n<ol>\n<li>로딩이 끝난 상태와 끝나지 않은 상태로 구분할 수 있다.</li>\n<li>로딩이 끝난 상태에서 실행하면 바로 호출이 될것이고</li>\n<li>로딩이 끝나지 않은 상태라면, callback 처럼 대기해서 완료되면 실행이 되도록 한다.</li>\n<li>그렇게 되면 async-nonblocking 코드를 sync-blocking 코드 처럼 우리가 보기 편하게 작성할 수 있다.</li>\n</ol>\n</li>\n<li>\n<p>위의 한가지 예는 completableFuture이다. 자바스크립트에선 promise와 동일하다고 생각하면 된다.</p>\n<ol>\n<li>한 가지 예를 들어보자. 공장에서 자동차를 조립하는데 타이어, 프레임, 휠, 운전대, 라이트, 엔진, 등을 모두 제조해서 조립을 한다고 생각해보자.</li>\n<li>그렇게 되면 차동차의 조립이 모두 성공하기 위해서는 각각의 부품들이 각 라인에서 생산되어 모두 나와야 완성된 자동차를 만들수가 있다.</li>\n<li>여기서 각각 부품들은 각각의 다른 스레드에서 생성하고, 모두 완성 되면 자동차를 조립하는 코드를 작성해보자.</li>\n</ol>\n</li>\n<li>\n<p>promise가 강력한 이유</p>\n<ul>\n<li>만약에 result는 비동기 논블로킹으로 요청을 하고, 밑에 코드를 동기적으로 작성할 수 있다. 그리고 나중에 result가 필요할 때 callback을 호출하게 하여 동작이 가능하다.(callback의 호출 시점을 제어할 수 있기 때문에 )</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> engineLine <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"engine finish\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"engine\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> frameLine <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"frame finish\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"frame\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> wheelLine <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wheel finish\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wheel\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> tireLine <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tire finish\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tire\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> finishLine <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"finish\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tire\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nengineLine<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>engineLine<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>frameLine<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>wheelLine<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>tireLine<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>finishLine<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>멀티 스레드 패턴</p>\n<ul>\n<li>IOC</li>\n<li>background 입력 스레드가 항상 버퍼를 갱신하고 다른 멀티스레드는 버퍼를 감시한다.</li>\n<li>suspended pattern이며 읽고 쓸때 syncronize를 할 필요가 없기 때문에 굉장히 빠르다.</li>\n</ul>\n</li>\n<li>\n<p>컴퓨터는 사실 비동기가 없다. 우리는 노이만 머신을 사용하기 때문에 한번에 명령이 적재되면 명령을 중간에 멈출 수 있는 방법이 없다. 무조건 모두 실행되야 하고 무조건 블로킹 당한다. 그러기 때문에 우리가 알고있는 비동기는 멀티스레드로 만든것이다. 멀티스레드는 왜 비동기가 될까? 명령을 멈출 수 있기 때문이다. 원래 노이만 머신은 메모리에 적재된 명령을 한번에 소진해야 되는데 스레드를 사용하면 1번 스레드가 자기에 적재된 명령을 실행하다 끊고 다른 스레드로 넘어가서 코드를 실행한다. 실질적인 시분할이 일어난다. 따라서 동기적인 명령을 멈출 수 있는 유일한 방법은 프로세스나 스레드밖에 없다. OS 차원에서 그외에 우린 동기적 명령을 멈출 수 있는 방법은 없다.</p>\n</li>\n<li>\n<p>그럼 언어에서는 가능할까? for문 돌때 break 같은 전용 flow 명령을 쓰지 않고, 3번 돌다가 멈췄다가 4번 돌다가 이렇게 하는 방법은 없다. 스레드만 os차원에서만 가능하다.</p>\n</li>\n<li>\n<p>그럼 언어 차원에서 그것을 흉내내기 위해 만든 문법이 yield 중간에 빠졌다가 들어가는데,</p>\n</li>\n</ul>\n<h4 id=\"2-코루틴\"><a href=\"#2-%EC%BD%94%EB%A3%A8%ED%8B%B4\" aria-label=\"2 코루틴 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 코루틴</h4>\n<p>리스코프 치환원칙 공부하기</p>","frontmatter":{"title":"코틀린 코드스피츠 continuation & cps 녹취록","date":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/study/코틀린 스터디 코루틴/","previous":{"fields":{"slug":"/study/그림으로 배우는 HTTP & Network Basic2/"},"frontmatter":{"title":"그림으로 배우는 HTTP & Network basic 2","category":"study"}},"next":{"fields":{"slug":"/study/그림으로배우는네트워크5/"},"frontmatter":{"title":"그림으로 배우는 네트워크 스터디 5","category":"study"}}}}