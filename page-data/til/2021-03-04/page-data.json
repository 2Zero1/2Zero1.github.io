{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/2021-03-04/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"c895a381-97a6-59e4-b6bb-bff566ff7b7c","excerpt":"fact 코드숨 6장 지역 리스트 부분 커밋 메시지를 나눠서 TDD로 진행 이력서 업데이트 dome을 깨우치다 책 읽고 쳐보기 feelings…","html":"<ol>\n<li>\n<p>fact</p>\n<ul>\n<li>코드숨 6장 지역 리스트 부분 커밋 메시지를 나눠서 TDD로 진행</li>\n<li>이력서 업데이트</li>\n<li>dome을 깨우치다 책 읽고 쳐보기</li>\n</ul>\n</li>\n<li>\n<p>feelings</p>\n<ul>\n<li>이력서를 작성하면서 이전 회사에서 진행한 프로젝트들을 포트폴리오에 넣을 수 없어서 작성할게 없다고 생각했지만, 회사 내에서 배우고 경험한 것들이 너무나 값지다고 느꼈다.  </li>\n<li>나는 너무 나에게 채찍질만 하는것 같다는 생각이 들었다. 나에게 너무 가혹한게 아닌가라는 생각이 들었다. 다른 사람들에겐 그러지 않으면서</li>\n<li>확실히 시간이 많으니 나를 돌아보게 되는 시간이 많아서 좋았다. 지식이나 학문적 성장이 아니라 위와 같은 내면의 성장을 할수 있어서 기쁘다.</li>\n<li>오늘 하루 모든것이 너무 좋다.</li>\n</ul>\n</li>\n<li>\n<p>finding</p>\n<ul>\n<li>\n<p>코드숨 6장</p>\n<ul>\n<li>reactRouter의 url/:value 형식으로 properties를 넘겨주는것을 알게되었다.</li>\n</ul>\n</li>\n<li>DOM을 깨우치다 (40p~60p)</li>\n<li>\n<p>document 노드는 DocumentType 노드 개체 하나와 Element 노드 개체 하나를 가질 수 있다.</p>\n<ul>\n<li>HTML 문서는 하나의 doctype(<!DOCTYPE html>)과 하나의 element(<html lang=\"en\">)를 갖는다.</li>\n<li>window.document개체와 Document개체를 혼동해서는 안된다. window.document는 DOM 인터페이스의 시작점이다.</li>\n<li>document.doctype은 &#x3C;!DOCTYPE>을 참조한다.</li>\n<li>document.documentElement는 <html lang=\"en\">을 참조한다.</li>\n<li>document.head 는 <head>를 참조한다.</li>\n<li>document.body 는 <body>를 참조한다.</li>\n<li>doctype이나 DTD의 nodeType은 10 또는 DOCUMENT<em>TYPE</em>NODE이며, DOCUMENT_NODE(즉 HTMLDocument()로부터 생성되는 window.document)와 혼동되어서는 안된다.</li>\n</ul>\n</li>\n<li>document.implementation.hasFeature()를 사용하면 현재 문서에 대해 브라우저가 구현/지원하는 기능 및 수준에 대해 물어볼 수 있다. 이것 외에 기능탐지(capability detect를 같이 사용해야한다.)</li>\n<li>\n<p>document.activeElement를 사용하면, 문서 내에서 포커스를 가지고 있거나 활성 상태인 노드에 대한 참조를 바로 얻을 수 있다.</p>\n<ul>\n<li>focus() 함수를 사용하여 포커스 설정을 할 수 있다.</li>\n<li>포커스를 가지고 있거나 활성 상태인 element는 포커스를 받을 수 있는 element를 반환한다. 브라우저에서 웹 페이지를 방문해서 탭 키를 눌러보면, 페이지 내에서 포커스를 받을 수 있는 element들로 포커스가 전환되는 것을 볼 수 있다.</li>\n</ul>\n</li>\n<li>document.hasFocus() 메서드를 사용하면, 사용자가 현재 해당 HTML 문서가 로드된 창에 포커스를 두고 있는지를 알 수 있다.</li>\n<li>\n<p>defaultView 속성은 js 최상위 개체, 혹은 전역 개체라고 불리는 것에 대한 바로가기다. 웹 브라우조에서 최상위 개체는 window 개체이므로, js 브라우저 환경에서 defaultView는 이 개체를 가르킨다.</p>\n<ul>\n<li>최상위 개체가 없는 DOM 이나 웹 브라우저 내에서 실행되는 않는 JS 환경(nodejs)의 경우, 이 속성은 최상위 개체 영역에 접근할 수 있게 해준다.</li>\n</ul>\n</li>\n<li>노드에서 ownerDocument 속성을 호출하면, 노드가 포함된 document에 대한 참조를 반환한다. 만약 iframe내에 포함된 개체에게 사용한다면, iframe내의 element에서 document 노드를 얻엉낸다.</li>\n<li>이곳부터 3장 Element 노드</li>\n<li>\n<p>HTML 문서 내의 각 element들은 고유한 성질을 가지며, 각자 element를 DOM트리 내의 노드 개체로 인스턴스화하는 고유한 js 생성자를 갖는다.</p>\n<ul>\n<li>예로 <a>element는 HTMLAnchorElement()생성자를 통해 DOM 노드로 만들어진다.</li>\n<li>DOM에서 각 element가 고유한 js 인터페이스/생성자를 통해 만들어진다.</li>\n</ul>\n</li>\n<li>\n<p>밑의 것들은 HTML element 노드에 존재하는 속성 및 메서드중 주요하게 생각되는 주요 속성과 메서드들이다.</p>\n<ul>\n<li>createElement()</li>\n<li>tagName</li>\n<li>children</li>\n<li>getAttribute()</li>\n<li>setAttribute()</li>\n<li>hasAttribute()</li>\n<li>remoteAttribute()</li>\n<li>classList()</li>\n<li>dataset</li>\n<li>attributes</li>\n</ul>\n</li>\n<li>\n<p>Element 노드는 브라우저가 HTML 문서를 해석해서 문서 컨텐츠를 기반으로 대응되는 DOM이 만들어질 때 인스턴스화 된다. 이것 외에 createElement()를 사용하여 프로그래밍 적으로 Element 노드를 생성할 수도 있다.</p>\n<ul>\n<li>createElement() 메서드에 전달되는 값은 생성할 Element의 형식(태그 이름)을 지정하는 문자열이다.</li>\n</ul>\n</li>\n<li>\n<p>tagName 속성을 사용하면, element의 이름에 접근할 수 있다. tagName 속성은 nodeName이 반환하는 것과 동일한 값을 반환한다.</p>\n<ul>\n<li>document.quertySelector(‘a’).tagName은 A가 출력된다.</li>\n</ul>\n</li>\n<li>\n<p>attributes 속성(element 노드가 Node로 부터 상속받음)을 사용하면, 현재 element에 정의된 Attr 노드의 컬렉션을 얻을 수 있다.</p>\n<ul>\n<li>attributes 속성을 통해 반환되는 배열은 라이브 상태이다. 이는 내용물을 다른곳에서 변경시 변경될 수 있다는 말이다.</li>\n<li>attributes 속성은 유사 배열 컬렉션이며, 읽기 전용인 length 속성을 갖는다.</li>\n</ul>\n</li>\n<li>\n<p>element의 attribute 값을 가져오고, 설정 및 제거하기 위한 가장 일관된 방법은 get,set,removeAttribute() 메서드를 사용하는 것이다.</p>\n<ul>\n<li>setAttribute()를 사용해 attibute값을 null이나 ”로 설정하지 말고 removeAttribute를 사용하기 바란다.</li>\n<li>일부 element attribute는 element 노드에서 개체 속성(document.body.id, document.body.className)으로 가지지만, 이 속성을 사용하지 말고 위의 메서드를 사용하도록 권고한다.</li>\n</ul>\n</li>\n<li>\n<p>element가 attribute를 가지고 있는지 판별하기 위해 좋은 방법은 hasAttribute() 메서드를 사용하는 것이다.</p>\n<ul>\n<li>element가 attribute를 포함하고 있으면(attribute가 값을 가지지 않더라도) true를 반환한다.</li>\n</ul>\n</li>\n<li>\n<p>element 노드에 존재하는 classList 속성을 사용하면 className 속성에서 반환되는 공백으로 구분된 문자열 값을 사용하는 것보다 훨씬 쉽게 class attribute 값 리스트에 접근할 수 있다.</p>\n<ul>\n<li>classList 는 유사 배열이며 읽기전용인 length를 갖는다.</li>\n<li>classList는 읽기 전용이지만, add, remove, contains, toggle 메서드를 사용해 변경 가능하다.</li>\n</ul>\n</li>\n<li>classList.toggle() 메서드를 사용하면, class attribute의 하위 값을 토글 시킬 수 있다. 이 메서드는 값이 누락된 경우 추가하거나 값이 이미 있는 경우 제거할 수 있게 해준다.</li>\n</ul>\n</li>\n<li>\n<p>Future Action Plan</p>\n<ul>\n<li>나한태 위로와 칭찬을 한다.</li>\n<li>너무 무리하지 말자</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"2021-03-04 TIL","date":"March 04, 2021"}}},"pageContext":{"slug":"/til/2021-03-04/","previous":{"fields":{"slug":"/til/2021-03-03/"},"frontmatter":{"title":"2021-03-03 TIL","category":"TIL"}},"next":{"fields":{"slug":"/til/2021-03-05/"},"frontmatter":{"title":"2021-03-05 TIL","category":"TIL"}}}},"staticQueryHashes":["3128451518","96099027"]}