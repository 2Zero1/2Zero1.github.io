{"componentChunkName":"component---src-templates-blog-post-js","path":"/study/kotlin continuation & cps/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"63afbbdc-f935-5ac1-b3db-1c52b1690a9b","excerpt":"continuation : 우리가 알고 있는 콜백과 부합 CPS : continuation을 실질적으로 응용하는 방식, 콜백을 패스하는 개념 Continuation & Sequence 밑의 코드 또한 continuation을 사용한다. c에는 cont가 없으면 a로 초기화 하고, 있으면 있던것을 쓴다. continuation func은 return 값으로 continuation을 반환 while…","html":"<ol>\n<li>continuation : 우리가 알고 있는 콜백과 부합</li>\n<li>CPS : continuation을 실질적으로 응용하는 방식, 콜백을 패스하는 개념</li>\n<li>\n<p>Continuation &#x26; Sequence</p>\n<ol>\n<li>밑의 코드 또한 continuation을 사용한다. c에는 cont가 없으면 a로 초기화 하고, 있으면 있던것을 쓴다.</li>\n<li>continuation func은 return 값으로 continuation을 반환</li>\n<li>while문의 조건 안에서는 반복적인 일 (밑의 코드의 주석으로 실행으로 표시한 부분) 이 이터레이션이다.</li>\n<li>이터레이션으로 보면 while의 조건이 hasNext continuation(3,cont)가 next 부분임. 그러므로 이런 continuation의 행동은 이터레이션에 수련하게됨.</li>\n<li>continuation을 쓰고 있는 코드의 분할을 자동으로 만들어 주는 것이 코틀린에서 고유명사 sequence이다. continuation 구문을 자동으로 만들어주는 이터레이션 생성기이다.</li>\n</ol>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> Cont<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> state <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">var</span> isCompleted <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token keyword\">var</span> result<span class=\"token operator\">:</span> T<span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        state<span class=\"token operator\">++</span>\n        result <span class=\"token operator\">=</span> v\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">complete</span><span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        isCompleted <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n        result <span class=\"token operator\">=</span> v\n    <span class=\"token punctuation\">}</span>\n\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">continuation1</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> cont<span class=\"token operator\">:</span> Cont<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> run <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> v<span class=\"token operator\">:</span> Int\n    <span class=\"token keyword\">val</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cont <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        v <span class=\"token operator\">=</span> a\n        <span class=\"token function\">Cont</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        v <span class=\"token operator\">=</span> cont<span class=\"token punctuation\">.</span>result<span class=\"token operator\">!!</span>\n        cont\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">//본문</span>\n    <span class=\"token keyword\">when</span> <span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token number\">0</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n\n            v<span class=\"token operator\">++</span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"state <span class=\"token interpolation variable\">$v</span>\"</span><span class=\"token punctuation\">)</span>\n            c<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token number\">1</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n            v<span class=\"token operator\">++</span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"state <span class=\"token interpolation variable\">$v</span>\"</span><span class=\"token punctuation\">)</span>\n            c<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n            v<span class=\"token operator\">++</span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"state <span class=\"token interpolation variable\">$v</span>\"</span><span class=\"token punctuation\">)</span>\n            c<span class=\"token punctuation\">.</span><span class=\"token function\">complete</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    c\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//실행</span>\n    <span class=\"token keyword\">var</span> cont <span class=\"token operator\">=</span> <span class=\"token function\">continuation1</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>cont<span class=\"token punctuation\">.</span>isCompleted<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        cont <span class=\"token operator\">=</span> <span class=\"token function\">continuation1</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> cont<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>cont<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p>이렇게 하면 만들 수 있음.</p>\n<ol>\n<li>continuation은 코드에 없으나 지가 알아서 만들것임</li>\n<li>yield() 를 쓸 때마다 iteration이 나눠지는것임</li>\n<li>왜 이렇게 짰는데 continuation이 생겨나는지는 컴파일러가 기능을 수행하기 때문이다.</li>\n<li>우리는 sync block 형태로 짜길 원한다 이게 이해하기 쉽다.</li>\n<li>\n<p>sequence란 block이 나오면 밑과 같이 짜면 컴파일러는 위의 코드처럼 만들어준다. 밑은 컴파일러가 하는것이다.</p>\n<ul>\n<li>continuation 객체를 만들고</li>\n<li>continuation 객체를 호출하는 형태로 변경</li>\n<li>안의 코드도 yield를 기준으로 각각의 케이스를 다른 스테이트로 나눠서 코드를 위의 when과 같이 바꿔줌</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> s <span class=\"token operator\">=</span> sequence <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> v <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n    v<span class=\"token operator\">++</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>'state $v\"<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">yield</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n    v<span class=\"token operator\">++</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>'state $v\"<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">yield</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n    v<span class=\"token operator\">++</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>'state $v\"<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">yield</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n    v<span class=\"token operator\">++</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">last</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>컴파일러는 sequence란 함수에 무슨 비밀이 있어서 이렇게 나눌 수 있는게 아니라 실제 sequence라는 애는 sequence context를 가지며  sequence context에 있는 메소드 yield를 호출 한것</li>\n<li>sequence는 수신함수(확장함수)이기 때문에 context로 sequence context를 받아 들임.</li>\n<li>sequence context 안의 메소드중 yield가 있기 때문에 sequence에서 사용할 수 있는것이다. 사실 this.yield임(왜 this를 생랴이 가능할까 ?)</li>\n<li>밑의 코드중 가장 중요한 부분은 suspendCoroutineUninterceptedOrReturn { c-> 부분이다.</li>\n<li>위의 c가 continuation이다.</li>\n<li>여기서 나오는 suspend는 위의 코드에서 when에 나오는 하나의 섹션을 의미한다. 한번에 이 코드를 실행하지 않고 분할해서 나눠줘야하는 지점을 suspend라고 부름</li>\n<li>위의 함수는 yield() 전까지 리턴이 된 상태임. 일반 적인 함수는 처음부터 시작해서 끝에서 끝나는데 코루틴이라는 형태의 함수들은 중간부터 중간을 리턴할 뿐만 아니라 중간부터 시작해서 중간을 리턴할수 있음 위의 코드와 같이 바뀌니까</li>\n<li>각 섹션의 yield()가 일어나기 전까지의 것 하나하나를 suspend라고 한다 함수가 끝까지 실행되지 않고 멈춘다는 것임 중간 리턴 때 멈춤</li>\n<li>그다음 suspend 된걸 재개하는데 이걸 resume 한다</li>\n<li>밑의 코드는 nextStep을 현재의 continuation으로 리턴한 것 처럼 continuation 리턴에서 nextStep은 여기서 안보이지만 sequence context의 속성인데 얘를 다음번 continuation으로 잡아주고 리턴 값을 suspend상태로 보내주는 것이다. yield하면 suspend이니까</li>\n<li>실제로 컴파일 타임에 이 코드를 나누게 되는 비밀은 suspendCoroutineUninterceptedOrReturn { c- >} 이다</li>\n<li>위의 것이 컴파일러가 직접 코드를 나누게 명령내리는 컴파일러 전용 명령이다.</li>\n<li>위의 것이 각각 continuation state로 나뉘어 지는 것이다. continuation state 1,2,3로나뉘어 지는 이유가 suspendCoroutineUninterceptedOrReturn얘임</li>\n<li>위의 것은 suspendCoroutine 로 부터 파생 되는데 내용을 보면 구현이 internal로 되있음 언어에 맞춰 시스템이 구현 한것이고 개발자가 할게 아님 컴파일러가 처리할 것임. suspendCoroutineUninterceptedOrReturn 지점을 기준으로 분해시키라고 컴파일러에게 명령을 내리는 것임 이곳이 suspend pointer라고  yield가 나올때 마다 컴파일러에게 시켜서 suspend pointer 마다 분해를 시키는것 그때마다 분할 하자마자 continuation이 생겨나는 것임 왜 continuation을 인자로 받는지는 시스템이 날라주고 시스템이 continuation을 만들기 때문.</li>\n<li>아까 위의 코드에선 우리가 만들었음. 이건 컴파일러가 continuation을 만드니까 컴파일러에게 받는것임.</li>\n<li>sequence는 실행은 하지 않는다. 직접 하나하나 실행 해줘야한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">suspendCoroutineUninterceptedOrReturn</span><span class=\"token punctuation\">(</span>block<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Continuation<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Any<span class=\"token operator\">?</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> T <span class=\"token comment\">//Continuation&lt;T> 얘가 바로 코루틴내장되어져 있는 continuation 객체이다</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">override</span> <span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">yield</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    nextValue <span class=\"token operator\">=</span> value\n    state <span class=\"token operator\">=</span> State_Ready\n    <span class=\"token keyword\">return</span> suspendCoroutineUninterceptedOrReturn <span class=\"token punctuation\">{</span> c <span class=\"token operator\">-></span>\n    nextStep <span class=\"token operator\">=</span> c\n    CORUTINE_SUSPENDED<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>CO : 일반적으로 코루틴 시스템이 적용되는 많은곳에서 수동으로 실행함수를 만들때 쓰는 기법</li>\n<li>자바스크립트의 generator는 sequence와 똑같은 기능을 함. yield를 호출할 때마다 suspend 구간이 생기고 거기에 continuation을 만들지만 es6에서는 continuation의 제어권을 직접 주진 않음.</li>\n<li>하지만 코루틴시스템에선 continuation 제어권을 인터페이스가 준다.</li>\n<li>제너레이터에서는 yield를 원하는 타이밍에 할 수 없음. 왜냐면 동기 로직 안에서 yield넣을수 있을 뿐 이 안에서 ajax callback에 yield를 하는건 불가능. 동기화 로직 yield밖에 안된다. 왜냐면 우리가 yield 할 때 continuation을 제어권 없이 yield 하는 타이밍에 continuation이 resume이 되기 때문이다.</li>\n<li>es8에서는 sync/await과 제너레이터를 결합해서 yield 타이밍을 미룰 수 있는 async generator가 있음 걔를 이용하면 sequence와 동등한 스펙을 구현할 수 있음.</li>\n<li>제너레이터 안에서는 조종할 수 없지만 밖에서 제너레이터를 이터레이션을 돌리는 코드를 원하는 타이밍에 이터레이션 될 수 있도록 하는것이 코루틴의 CO의 원리이다.</li>\n<li>제너레이터 또는 코루틴의 구현체가 단방향인 경우 코루틴 안에서 밖으로  이터레이션 값을 줄 수 있지만, 밖에서 코루틴 안으로 이터레이션 값을 줄수는 없다.</li>\n<li>es6  제너레이터는 yield도 받고 next에 괄호 열고 값을 넣어줄 수도 있음. 그러면 코루틴에서는 못쓰는  a = yield(30) 이런 값을 받을 수 있음. 양방향 통신을 함. 밖에서 제너레이터 안으로 yield로 인자를 여러번 보낼 수 있음.</li>\n<li>yield 상태에선 통신이 안되기 때문에 최초 함수의 인자는 받을 수 있지만 안에 있는 코루틴 이터레이션에서는 중간에 인자를 받을 수 없다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> State<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n    <span class=\"token keyword\">lateinit</span> <span class=\"token keyword\">var</span> target<span class=\"token operator\">:</span>Promise<span class=\"token operator\">&lt;</span>Response<span class=\"token operator\">></span> <span class=\"token comment\">// 현재는 null</span>\n<span class=\"token punctuation\">}</span>\nsequence<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> s <span class=\"token operator\">=</span> <span class=\"token function\">State</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//최초의 스테이트 탄생 시킴</span>\n    s<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token function\">Request</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\">//window.fetch는 promise&lt;Response>를 리턴하는 promise</span>\n    <span class=\"token function\">yield</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>    <span class=\"token comment\">//yield로 state 객체 자체를 보냈음.</span>\n    s<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token function\">Request</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//얘는 외부의 인자를 받아왔을 것임. 이것을 통해 외부와 대화를 할 수 있게 됬음. s객체의 result만 갱신하는 걸로 코루틴 안에서 밖깥쪽의 값을 얻어올 수 있음.</span>\n    <span class=\"token function\">yield</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">co</span><span class=\"token punctuation\">(</span>it<span class=\"token operator\">:</span>Iterrator<span class=\"token operator\">&lt;</span>State<span class=\"token operator\">></span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> seq<span class=\"token operator\">:</span> SequenceScope<span class=\"token operator\">&lt;</span>State<span class=\"token operator\">></span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">//sequenceScope의 타입이 state인 이유는 밑의 yield에서 s(State)를 보내기 때문에 타입 확정</span>\n    <span class=\"token keyword\">val</span> iter <span class=\"token operator\">=</span> it <span class=\"token operator\">?</span> <span class=\"token operator\">:</span>seq<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?:</span> <span class=\"token keyword\">throw</span> <span class=\"token function\">Throwable</span><span class=\"token punctuation\">(</span>\"invalid<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>iter<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">let</span> <span class=\"token punctuation\">{</span>st <span class=\"token operator\">-></span>\n       st<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">{</span>it<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">{</span>\n           st<span class=\"token punctuation\">.</span>result <span class=\"token operator\">=</span> it\n           <span class=\"token function\">co</span><span class=\"token punctuation\">(</span>iter<span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//첫번쨰 인자는 없으면 알아서 null 처리 함</span>\n<span class=\"token function\">co</span><span class=\"token punctuation\">(</span>sequence<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> s <span class=\"token operator\">=</span> <span class=\"token function\">State</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    s<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token function\">Request</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\">//window.fetch는 promise를 리턴함. a.txt를 날릴 껀데 여기 까지가 promise&lt;Response>를 주는 promise이다</span>\n    <span class=\"token function\">yield</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n    s<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token function\">Request</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//코루틴 안쪽에서 밖의 값을 얻어올 수 있음. 이런 방식으로</span>\n    <span class=\"token function\">yield</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>  </code></pre></div>\n<ul>\n<li>위의 코드에서 중간에 대화를 할 수 있게끔 하기 위해 기본적인 target을 Promise&#x3C;Response>로 지정</li>\n<li>양방향 통신이 안되는 코루틴 같은 시스템에서는 직접 양방향 통신을 위한 메모리 공간을 갖고 있는객체를 외부에 출력해 줘야지만 그 객체의 속성을 안에서 이용할 수 있음.</li>\n<li>그래서 yield로 부터 리턴값을 받아온건 아니지만 s의 속성으로 받아올 수 있음.</li>\n<li>하지만 위까지는 안쪽 사정이고 우리는 시퀀스를 이용하는 CO 함수를 만들고 싶은것이다.</li>\n<li>막 점프하고 하는게 너무 복잡하고 그러니 간단하게 sync block방식으로 사용하게 끔 co가 나온것</li>\n<li>co 코드의 SequenceScope&#x3C;State> 가 sequence함수의 리턴값 왜 State냐면 yield 할떄 입력값이 State() 이기 때문.  </li>\n<li>co 코드의 iterator는 contination의 passing에 의해 iterator가 직접 있는 경우와 없으면 seq?.iterator()로 받아오고 있음. 근데 둘다 안줬으면 Throw를 날림</li>\n<li>seq는 iteration을 return 함</li>\n<li>iter.next()는 State 객체가 나옴 . 위의 seq 스테이트 객체를 반환하는 iteration을 갖고 있는 seq 이기 때문이다.</li>\n<li>State는 Promise&#x3C;Response>임.</li>\n</ul>\n<h5 id=\"suspend--coroutine\" style=\"position:relative;\"><a href=\"#suspend--coroutine\" aria-label=\"suspend  coroutine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>suspend &#x26; coroutine</h5>\n<ul>\n<li>cps와 suspend 와 코루틴을 이용하여 섹션을 만들어 내서 continuation을 자동으로 만들어줄 수 있다라는 기본 개념을 알게 되었고,</li>\n<li>이전까지완 지금부터는 다른데 위에서 배운 기저 시스템을 이용해서 async generator처럼 비동기로 실행되지만 section 구분을 자동으로 컴파일러에게 의뢰해서 구문들을 만들어내는 일종의 닉네임들과 여러가지 니모닉으로 이루어져 있는 시스템을 제안함</li>\n<li>결국 여기나오는 것들은 sequence와 continuos resume으로 다 번역이 됨 하지만 이것 깊숙히 감쳐줘 있고 이걸 추상화 하여 추상화한 객체끼리 통신들을 그 위에층에 만든것임 결국 위에층이 밑에 층에 깔린걸로 바뀜</li>\n<li>위에서는 아얘 다른 언어로 만들어 놨음.(DSL)이걸 이해하기 위해선 윗쪽의 것들을 다 이해 해야한다.</li>\n<li>코틀린 코틀린 생태계에서 나오는 coroutines는 위에서 나왔던 coroutine과는 다른 애다 고유 명사임</li>\n<li>서브루틴이란 반복된 로직이 있는 경우 함수안에 가둬놓고 재활용해서 호출함으로 써 재활용 하는것</li>\n<li>서브루틴 특징으로 인자와 리턴값이 있어서 서브루틴 내부가 위에서 아래로 한번 실행되는게 특징 이었음. 얘는 한번 돌고 끝이남</li>\n<li>코루틴은 함수의 진입접과 리턴은 있을지 몰라도 중간에 계속해서 빠져나오고 진입할 수 있는 yield라는 공간들이 있어서 함수의 처음 호출 이외에도 여러번 진입 나오기 진입 나오기를 반복할 수 있는 스타일을 코루틴이라고 부름. co(복수) routine</li>\n</ul>\n<h6 id=\"kotlin-coroutines\" style=\"position:relative;\"><a href=\"#kotlin-coroutines\" aria-label=\"kotlin coroutines permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>kotlin coroutines</h6>\n<ul>\n<li>가장 핵심 적인 내용은 coroutineContext get(key):Element : 엘리먼트 라는 애의 컨테이너다 라고 생각하면 된다.</li>\n<li>코루틴 컨텍스트가 하나 있으면 여기에 element를 잔뜩 집어넣을 수 있음. map 이랑 set 같은 놈임</li>\n<li>그래서 coroutineContext element를 의존한다. 보유도 하고 있다. corutineContext -> element</li>\n<li>그래서 coroutineConext == element 라고 해도 됨</li>\n<li>하지만 그 coroutineContext가 element의 구상체임에 불구하고 다른점은 element의 컨테이너 이기도 하다</li>\n<li>element를 job과 dispatcher가 상속을 함.</li>\n<li>dispatch : 아까 우리가 만든 sequence가 아니라 코어 함수에 해당하는 실행기. 얘각 바로 실행해주는애. 우리가 만든애는 실행기가 아니라 sequence를 실행해줄 코어 함수가 필요 했음 .</li>\n<li>코루틴 컨텍스트는 실행기인 dispatcher도 소유하고 아까 sequence까 만들어준 iteration 객체 하나하나가 job이다</li>\n<li>코루틴 컨텍스트는 시퀀스 마냥 여러개의 이터레이션 객체들을 소유하고 그것을 실행하는 코어함수인 dispatcher를 소유하는 객체임.</li>\n<li>대부분의 코루틴컨텍스트는 하나의 dispatcher와 다수의 job으로 이루어져있음.</li>\n<li>서스펜드 코루틴 섹션을 만들어주는 시스템과 코어라는 이터레이션 실행기를 객체로 역활모델로 추상화 한게 코루틴 컨텍스트가 걔내들을 다 소유하는 컨테이너가 되고 이안에 실행기의 디스패처와 각각 이터레이션 나타내게 되는 잡들을 집어 넣게 되는것임.</li>\n<li>job은 하나의 이터레이션을 추상화했기 때문에 대략 얼추 비슷한 기능을 갖고 있는 메소드가 제공된다 아까는 switch로 나눈 구문이 무조건 실행됬는데 이 안의 메소드 호출에 따라서 실행할지 말지 대기할지 추상화를 해놓은것임 이 일이 끝난 후에 continuation의 resume을 부르는 것은 당연한대 resume 부르는 행위를 언제할지를 추상화 시켜놔서 우리에게 추상화된 개념으로 제공해줌 하나의 이터레이션에 해당하는 녀석임</li>\n<li>하지만 sync 로직만 커버함</li>\n</ul>\n<p><img src=\"/til/images/kotlin/coroutineContext.png\" alt=\"coroutineContext\"></p>\n<ul>\n<li>처음 만든 sequence는 syn 로직이었는데 두번째로 한 promise는 밖에 있는 co 실행기가 then을 통해 resume을 시켰기 때문에 비동기 적으로 구현됬음. 하지만 자바는 promise와 비슷한 completedFuture라는 추상객체가 있음.</li>\n<li>job을 상속해서 deferred라는 애를 만듬 얘는 then과 마찬가지로 await하는 시점에 모든 비동기가 해결 됬을때 resume을 호출해 주는 job으로 부터 상속받은 비동기를 처리하기 위한 것 promise와 비슷함</li>\n<li>yield를 상수값으로 할 경우 동기적으로 내보내면 되지만 promise같은 애가 개입하면 아까 co에서 promise.then을 처리한 다음에야 우리가 co를 다시 호출할 수 있었음.</li>\n<li>마찬가지로 힌트를 줘야함. 이 이터레이션이 동기적인 명령인지 아니면 비동기의 완료시점에 resume을 해줘야하는지 알아야함 내부적으로 이것을 추상화하고 있는 객체가 deffered</li>\n<li>deferred는 then과 마찬가지고 await하는 시점에 비동기가 모두 해소됬을 때 resume을 해소해주는 promise then을 똑같이 해준것 같은 job을 상속받은 비동기를 처리하기 위한 객체임</li>\n<li>동기적인 iteration은 다 job에 때려박고, 비동기 적인iteration은 다 deferred에 때려박음</li>\n<li>deferred에 때려박으면 await 시점에 resume이 일어나고 job은 바로 start가 일어나서 join될때까지 바로 실행 되는것임</li>\n<li>job과 deffered는 coroutine builder라는 애로 만든다.</li>\n<li>launch를 이용하면 job을 만들 수 있고, async를 이용하면 deffered를 만들 수 있음.</li>\n<li>둘중 하나를 만들어 coroutineContext에 빡빡 밟아주고 ..?? 실행하면 얘가 디스패처로 통해 자기가 쌓아놓은 job과 deferred를 co처럼 돌아가면서 이터레이션 실행한다.</li>\n<li>그럼 job과 deffered로 만든 이 생태계를 아까처럼 switch 문으로 나눠주는 컴파일 과정이 있어야되는데 여기서 job과 deffered를 실행기인 dispatcher로 실행할 거지만 니가 내가만든 동기 코드를 job이나 deffered에 이 시점을 바탕으로 스위치 문을 다 state문으로 나눠 continuation 객체까지 다 연결해 줘야되 라는 지시를 컴파일러에게 해줘야하는데 .</li>\n<li>이 동네 전체를 한꺼번에 suspend coroutine 하라는 키워드를 지정할 수 있는데 그것이 바로 suspend이다.</li>\n<li>함수 앞에 suspend를 붙히면 그 함수 전체는 job 또는 deferred의 기준으로 자동으로 continuation section을 컴파일러가 만들어줌</li>\n<li>우리는 cps 스타일 위에 sequence 시스템이 어떻게 움직이는지 suspend coroutine 함수가 시스템에 어떤 영향을 끼치는지 그 시스템을 추상화 해서 어떠한 구조로 만들어서 언어가 그위에 구축되어져 있는지 배움</li>\n<li>밑의 코드는 지금까지의 지식을 바탕으로 아까 sequence가 만들어내던 yield 함수가 suspend coroutine을 쓰는걸 직접 써보자는 것임 직접 우리가 yield함수를 흉내내서</li>\n<li>밑의 함수는 컴파일러에게 명령을 내리는 함수이다. 얘가 등장하는 순간 continuation switch section을 나눠줌 suspendCoroutine은  인자로 continuation을 받음 컴파일러가 만들어준 continuation을 받을 수가 있음. 이 섹션을 더이상 진행할지 말지는 cont.resume으로 결정한다. resume일때 값을 리턴한다. block은 T를 넘길수 있는 함수를 인자로 받는 함수이다. 그렇기 때문에 밑의 코드에 블록 안에 있는 cont.resume(it)는 T를 넘길 수 있는 함수이다.</li>\n<li>suspend 함수는 컴파일러가 이 전체를 suspendCoroutine이나 suspendCoroutine을 추상화 하고 있는 job 또는 deferred를 기준으로 switch를 나눠줌</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">suspsend <span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span>task<span class=\"token operator\">:</span><span class=\"token punctuation\">(</span>block<span class=\"token operator\">:</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>Unit<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>Unit<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>T <span class=\"token operator\">=</span> suspsnedCoroutine<span class=\"token punctuation\">{</span>\n    con<span class=\"token operator\">:</span>Continuation<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">-></span>block<span class=\"token punctuation\">{</span>cont<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">//얘가 b가 됨</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">{</span><span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// ((T->Unit)->Unit 여기의 it은 (T->Unit)에 해당</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><img src=\"/til/images/kotlin/coroutineBuilder.png\" alt=\"coroutineContext\"></p>\n<ul>\n<li>\n<p>block, non-block</p>\n<ol>\n<li>\n<p>block : 점유하는 시간만큼 블록을 일으키는 함수</p>\n<ul>\n<li>서브루틴이 끝난 후 제어권을 반환</li>\n<li>독점적인 cpu 점유로 인해 모든 동작이 정지됨</li>\n<li>블로킹의 조합을 예측할 수 없음.</li>\n<li>첫번째 코드가 예시임</li>\n</ul>\n</li>\n<li>\n<p>non-block : 서브 루틴이 즉시 플로우 제어권을 내놓는 것.</p>\n<ul>\n<li>두번째 코드</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> f <span class=\"token operator\">=</span> v <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">++</span> <span class=\"token operator\">&lt;</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">10000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">consta<span class=\"token operator\">=</span><span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">looper</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span> console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">backRun</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span><span class=\"token operator\">=></span>v<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> v<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//어쨌든콘솔은123부터출력</span></code></pre></div>\n<ul>\n<li>\n<p>sync, async</p>\n<ol>\n<li>\n<p>sync : 서브루틴이 즉시 값을 반환함.</p>\n<ul>\n<li>첫번째 코드</li>\n</ul>\n</li>\n<li>\n<p>async : 서브루틴이 콜백을 통해 값을 반환함.</p>\n<ul>\n<li>두번째 코드</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">double</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">v</span><span class=\"token operator\">=></span>v<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">double</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//4</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">double</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">v<span class=\"token punctuation\">,</span> f</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>v<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">double</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//4</span></code></pre></div>\n<ul>\n<li>\n<p>sync block</p>\n<ol>\n<li>sync : 서브루틴이 즉시 값을 반환</li>\n<li>block : 하지만 즉시 플로우 제어권을 반환 않음</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">sum</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> sum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>sync non-block</p>\n<ol>\n<li>sync : 서브루틴이 리턴 값으로 반환</li>\n<li>non-block : 즉시 플로우 제어권을 반환</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">sum</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>isComplete<span class=\"token operator\">:</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">_</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> sum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n        result<span class=\"token punctuation\">.</span>isComplete <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        result<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> sum<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>result<span class=\"token punctuation\">.</span>isComplete<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>async block</p>\n<ol>\n<li>async : 서브루틴이 콜백을 통해 값을 반환</li>\n<li>block : 즉시 플로우 제어권을 반환하지 않음</li>\n<li>\n<p>예</p>\n<ul>\n<li>node의 async로 block인 jdbc를 사용 ?</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">sum</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n<span class=\"token punctuation\">,</span> f</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> sum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">123</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//55 → 123</span></code></pre></div>\n<ul>\n<li>\n<p>async non-block</p>\n<ol>\n<li>async : 서브루틴이 콜백을 통해 값을 반환</li>\n<li>non-block : 즉시 플로우 제어권을 반환</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">sum</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n<span class=\"token punctuation\">,</span> f</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">_</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> sum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> console<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">123</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//123 → 55</span></code></pre></div>\n<ul>\n<li>\n<p>blocking non-blocking 과 sync 와 async는 논의하는 관점이 좀 다르다 실제로 나의 생각이지 정확한 것은 아니다 고민해 보고 수정할 생각이다.</p>\n<ol>\n<li>blocking non-blocking은 실행 방식에 따른 관점이다. 실제로 sync 방식으로 할 경우 blocking을 피할 수가 없다. async로 할 경우, 다른 스레드에 실행을 시키기 떄문에 현재 스레드는 non-blocking으로 동작 할것이다.</li>\n<li>sync async는 메모리에 적재된 명령을 순서대로 실행하는 실행 순서에 대한 관점이다. async로 할 경우, 해당 콜백이 언제 실행될지 우리는 예측을 할 수가 없다. 다른 스레드에서 돌고 있기 때문에. 만약에 다른 스레드에서 콜백이 실행 되도록 해놓는다면, 당연히 sync는 메모리에 적재된 순서대로 실행하지 않을것이다.</li>\n</ol>\n</li>\n<li>밑의 코드를 보면 main을 Coroutine$main.doResume이라는 함수를 자동으로 만들어 내는데 자동으로 만들어내는걸 보면 do 하면서 본인의 state_0 본인이 continuation임 println(a)하고 그다음 result 안에 task를 넣어줌. task 가 continuation this를 받아감. 이 task가 이때 컨티뉴에이션 객체를 이때 받는거랑 마찬가지임 . 우리가 만든 테스크가 어떻게 continuation 객체를 받냐고 시스템이 만든 continuation 객체가 여기에 온것임. suspend 함수가 이렇게 나누는 것임.</li>\n<li>실제로는 두덩어리임 println(‘a’)까지는 suspend coroutine 부분이 아니라 println(tast{it(‘b’)}) 까지가 한덩어리고</li>\n<li>suspend coroutine을 기준으로 println(“C”)만 한덩어리고</li>\n<li>위의 두개가 실행되고 전달되서 마지막이 실행됨</li>\n<li>자동으로 resume을 때리면 밑의 doResume으로 들어오게됨 다시</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">suspsend fun <span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span>task<span class=\"token operator\">:</span><span class=\"token punctuation\">(</span>block<span class=\"token operator\">:</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>Unit<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>Unit<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span><span class=\"token constant\">T</span> <span class=\"token operator\">=</span> suspsnedCoroutine<span class=\"token punctuation\">{</span>\n    con<span class=\"token operator\">:</span>Continuation<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token operator\">-</span><span class=\"token operator\">></span>block<span class=\"token punctuation\">{</span>cont<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">//얘가 b가 됨</span>\n<span class=\"token punctuation\">}</span>\n\nsuspend fun <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">{</span><span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// ((T->Unit)->Unit 여기의 it은 (T->Unit)에 해당</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">Coroutine$main</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">doResume</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state_0<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">case</span> <span class=\"token number\">0</span><span class=\"token operator\">:</span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state_0 <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>result_0 <span class=\"token operator\">=</span> <span class=\"token function\">task</span><span class=\"token punctuation\">(</span>main$lamda<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>result_0 <span class=\"token operator\">===</span> <span class=\"token constant\">COROUTINE_SUSPENDED</span><span class=\"token punctuation\">)</span>\n              <span class=\"token keyword\">return</span> <span class=\"token constant\">COROUTINE_SUSPENDED</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token operator\">:</span>\n              <span class=\"token keyword\">throw</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>exception_0<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> <span class=\"token number\">2</span><span class=\"token operator\">:</span>\n              <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>result_0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">default</span><span class=\"token operator\">:</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state_0 <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n              <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"State Machine Unreachable execution\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>우리는 suspend coroutine에서 continuation가 이 로직의 바로 다음번으로 전개될 수 있는 방법이란걸 알고 있으니 타임아웃을 만들어 볼 수 있다.</li>\n<li>time아웃 원리는 원하는 시간을 t로 받고 리턴을 할 필요가 없음.</li>\n<li>쟤는 task함수를 이용해서 suspendCoroutine에 진입 한것임</li>\n<li>task는 window.setTimeout에 t만큼 돈 다음 실행되는 람다 안에서 받아온 it (위 코드의 cont.resume(it))에 Unit을 줬음.</li>\n<li>그래서 밑에 애는 시간만 끌고 resume을 해준것이다.</li>\n<li>a가 출력되서 windowSetTimeout 1초가 지난 후에나 b가 출력됨</li>\n<li>suspend의 resume이 저때 발생하기 때문이다.</li>\n<li>timeout은 리턴값이 없지만 window.setTimeout을 끌어주는 효과가 생김</li>\n<li>밑의 코드를 보면 async non-blocking 함수를 sync blocking 형태로 사용할 수 있게 되었음.</li>\n<li>a와 b가 동기라면 바로 나와야 하는데 중간에 비동기이면서 async 스타일을 사용하고 있는  setTimeout이 껴들어 있는데도 불구하고 sync blocking 스타일로 쓸 수 있게 됬다.</li>\n<li>밑과 같이 써서 a 다음 비동기 적으로 1초가 지나고 b가 호출 되었음.</li>\n<li>여기 1초는 동기형으로 blocking 하고 있지 않음 . 여기서 유아이 다 움직인다.</li>\n<li>timeout이 블로킹 하고 있지 않는데 밑의 코드는 순서대로 실행이 된다.</li>\n<li>코루틴은 언어의 특정 문법을 사용하면 컴파일러가 스위치 컨티뉴에이션으로 바꿔주는 행위이다 .</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">suspend fun <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">:</span>Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>Unit <span class=\"token operator\">=</span> task<span class=\"token punctuation\">{</span>window<span class=\"token punctuation\">.</span><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token function\">it</span><span class=\"token punctuation\">(</span>Unit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n\nsuspend fun <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p>suspendCancellableCoroutine</p>\n<ol>\n<li>suspsnedCoroutine와 다르게 예외처리를 할 수 있음.</li>\n<li>밑의 차이는 resumeWithException 를 사용할 수 있다는 것임</li>\n<li>우리는 suspendCoroutine 섹션에서 우리가 원하는 시점에 continuation resume을 때릴 수 있다는 사실을 알고 있다.</li>\n<li>그러면 continuation resume말고 promise 면 reject일때 어떻게 할건가? resumeWithException으로 처리하면 된다.</li>\n<li>continuation객체에 일반적인 레포트를 받아주는 resume과 예외적인 레포트를 받아주는 resumeWithException이 있다.</li>\n<li>어떻게 window.fetch(Request(“a.txt)).await()는 response이다. 왜냐면 window.fetch(Request(“a.txt))가 Promise&#x3C;response>를 리턴할 것이고, await의 리턴값을 보면 T를 리턴하기 때문에 response를 리턴한다.</li>\n<li>reponse1.text()하면 String을 반환하는 promise 객체가 나올 것임. await 을 하면 string 나올것이고 .</li>\n<li>javascipt와 굉장히 유사하다 . async라는 키워드 대신에 suspend를 썼고 await라는 언어 수준의 여기에 있는 수신함수를 치환한것 뿐이다.</li>\n<li>다른 함수는 continuation의 resume에 접근할 수 없게 만든다. 코틀린은 그와 다르게 suspendCoroutine만 부르면 coroutine iterator 섹션으로 바꿔준다. 그리고 니가 맘대로 하게 해주고 resume 또한 마음대로 할 수 있음 .</li>\n<li>cps를 이해하고 cps가 실제적으로 섹션구분으로 continuation 섹션을 만들어내는 과정도 이해하고 얘의 실행기도 이해하면 코루틴이 쉽다.</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token function\">task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>block<span class=\"token operator\">:</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>Unit<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>Unit<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> T <span class=\"token operator\">=</span> suspendCoroutine<span class=\"token punctuation\">{</span>\n    cont<span class=\"token operator\">:</span>Continuation<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">-></span>block<span class=\"token punctuation\">{</span>cont<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> Promise<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> T <span class=\"token operator\">=</span> suspendCancellableCoroutine <span class=\"token punctuation\">{</span>\n    cont<span class=\"token operator\">:</span> CancellableContinuation<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">-></span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>\n        onFulfilled <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>cont<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n        onRejected <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>cont<span class=\"token punctuation\">.</span><span class=\"token function\">resumeWithException</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> response1 <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token function\">Request</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> text1 <span class=\"token operator\">=</span> response1<span class=\"token punctuation\">.</span><span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> response2 <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token function\">Request</span><span class=\"token punctuation\">(</span>text1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> text2 <span class=\"token operator\">=</span> response2<span class=\"token punctuation\">.</span><span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>text2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p>launch &#x26; async</p>\n<ol>\n<li>launch 는 Job을 async는 deffered를 만든다.</li>\n<li>그러면 실제 suspend 안에서 launch나 async로 만들어져 있는 job이 continuation section을 나눠주는건 아니고, job같은 경우 내부에서 starting 모드를 결정할 수 있다.</li>\n<li>인자 값으로 context를 받고 빌더함수가 만드는 job을 어떤 context(container contextContainer는 element 컨테이너이고 job도 element이다.)에 넣을건지에 대한 거다.</li>\n<li>아래서 넣은 EmptyCoroutineContext는 dispatcher도 아무 element도 없을것 같지만 시스템이 인지해서 이게 empty라면 기본 디스패처를 넣어주고 기본 잡을 넣어준다.</li>\n<li>인자값 start는 DEFAULT일 경우에 런치로 만들어진 즉시 start를 때림</li>\n<li>job은 리턴값이 없음 안에 있는 블록을 무조건 실행한다. 그럼 안에 있는 블록도 suspended 블록이기 때문에 다시 suspend 요소들을 가져올 수 있다. 여기에 동기화 로직만 들어가는게 아니다 suspend안에 suspend가 있으면 switch문 안에 어떤 case에 들어가는 switch문이 생긴다. 왜냐면 하나의 suspend section은 계속해서 do Resume에서 봤던것 처럼 switch문으로 바뀌기 때문 switch 문에 또 switch문이 생길 것임.</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">{</span>\n        context <span class=\"token operator\">=</span> EmptyCoroutineContext<span class=\"token punctuation\">,</span>\n        start <span class=\"token operator\">=</span> CoroutineStart<span class=\"token punctuation\">.</span>DEFAULT\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>두번째엔 context에 Dispatchers.Default를 넣었는데 dispatcher는 element이긴 한데 coroutine context는 아니었음. 그걸 launch에 넘겨주면 얘를 담고 있는 빈 context를 만들어줌. 그냥 dispatcher만 넣으면 이것만 넣어서 컨텍스트를 만들어준다. 이 디스패처에 따라 어떤 실행기가 이터레이션을 처리할지가 결정이 된다. 실행기가 a스레드와 b스레드에 실행되는게 있다면 어떤 디스패처를 고르냐에 따라 어떤 스레드에서 처리될지 결정된다. 스레드 환경에서는 보통 디스패처가 어떤 스레드를 쓰냐가 중요해지기 때문에 스레드를 고르는 행위나 코루틴 풀에서 작동시킬 거냐 에 따라 달라진다.dispatcher가 스레드를 결정하기 때문에 중요하다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">{</span>\n        context <span class=\"token operator\">=</span> EmptyCoroutineContext<span class=\"token punctuation\">,</span>\n        start <span class=\"token operator\">=</span> CoroutineStart<span class=\"token punctuation\">.</span>DEFAULT\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token comment\">//join()을 걸면 위에것이 끝나야 밑의것이 시작됨.</span>\n\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">{</span>\n        context <span class=\"token operator\">=</span> Dispatchers<span class=\"token punctuation\">.</span>Default<span class=\"token punctuation\">,</span>\n        start <span class=\"token operator\">=</span> CoroutineStart<span class=\"token punctuation\">.</span>DEFAULT  <span class=\"token comment\">//.LAZY를 할경우</span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token comment\">// .start()를 해줘야함.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p>그래서 job의 특징</p>\n<ol>\n<li>안에서 suspend 구문을 지원하긴 하지만 무조건 위에서 아래로 흐르는 로직 이외는 지원하지 않는다.</li>\n<li>리턴값이 없고 안이 무조건 실행된다. 그래서 launch 이다. 그냥 쏘면 걍 안이 실행될 뿐 더이상 할 수 있는게 없다. 얘는 continuation resume을 쓸수가 없음. 코틀린 코루틴 생태계에서 job이나 deffered를 쓰면 문제점은 우리가 컨티뉴에이션의 리쥼에 대한 통제권을 잃는다.그래서 블록 안에 동기적으로 실행되는것밖엔 안된다. 블록 안에서 ajax 콜백에서 리쥼같은건 못함 걍 흘러내림</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> a <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">async</span><span class=\"token punctuation\">{</span>\n        context <span class=\"token operator\">=</span> EmptyCoroutineContext<span class=\"token punctuation\">,</span>\n        start <span class=\"token operator\">=</span> CoroutineStart<span class=\"token punctuation\">.</span>DEFAULT\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token comment\">//join()을 걸면 위에것이 끝나야 밑의것이 시작됨.</span>\n    <span class=\"token keyword\">val</span> b <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">async</span><span class=\"token punctuation\">{</span>\n        context <span class=\"token operator\">=</span> Dispatchers<span class=\"token punctuation\">.</span>Default<span class=\"token punctuation\">,</span>\n        start <span class=\"token operator\">=</span> CoroutineStart<span class=\"token punctuation\">.</span>DEFAULT  \n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p>async</p>\n<ol>\n<li>asyncDml deffered 객체의 특징은 결과값이 나온다.</li>\n<li>단 async 블록이 만든건 deffered객체이지 값이 아니다</li>\n<li>미래의 a를 반환할 deffered객체가 위에 a에 잡힐것임</li>\n<li>deffered특징은 await을 통해 일정시점이 지난 다음 continuation(iteration) 때 우리는 async의 결과값을 받을 수 있다.</li>\n<li>start 인자가 default라 두 블록이 실행되자마자 실행이 되버림 그래서 밑에 동시에 값이 나옴.</li>\n<li>launch와 다른점이 외부세계와 대화를 할 수 있다.블록 내부의 값이 외부에 노출이 가능하다. deferred의 장점은 deffered안의 값을 리턴할 수 있다.</li>\n<li>deffered await을 통해 블록내부의 값이 해소됬을때 그 값을 외부에 노출할 수 있다.</li>\n<li>만약 b의 start 인자가 lazy라면 언제 start 될까? b.await할때 시작된다.</li>\n<li>아니면 b.start를 밑에서 한다면 동시에 나온다.</li>\n<li>job이나 deffered의 특징은 내부에서 low 레벨의 continuatino을 만나지 않는다. 그리고 중간에 resumeWithException을 가질 수 있다.</li>\n<li>하지만 우리한태 언제 resume을 호출할지에 대한 권한은 없어진다.</li>\n<li>resume을 우리가 원할때 호출하고 싶다면 suspendCoroutine 시스템 함수를 이용해서 섹션을 만들어내는 수밖에 없다.얘만이 컨티뉴에이션을 준다.</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token function\">async</span><span class=\"token punctuation\">(</span>block<span class=\"token operator\">:</span> <span class=\"token keyword\">suspend</span> CoroutineScope<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> T<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">async</span><span class=\"token punctuation\">{</span><span class=\"token function\">block</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">lauch</span><span class=\"token punctuation\">(</span>block<span class=\"token operator\">:</span> <span class=\"token keyword\">suspend</span> CoroutineScope<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">{</span><span class=\"token function\">block</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>suspendCoroutine을 사용하는 블록을 task로 추상화를 위에서 시켰었는데 그럼 나와있는 빌더를 이용한 글로벌 스코프 async나 global scope launch도 위와같이 추상화 시킬 수 있음.</li>\n<li>async를 보면 suspend CoroutineScope를 수신함수로 받는 인자를 받아서 오른쪽에 직접 블록을 넘겨주면 된다.</li>\n<li>async launch task를 이용하면 손쉽게 우리가 원하는 yield를 정리해서 끼워넣을 수 있음. 그럼 위에서 아래로 읽으면 비동기로 쳐리되지만 sync blocking 으로 보인다.</li>\n<li>다른 비동기 로직들은 callback을 이용하는데 이것의 나쁜점은 어휘공간이 보존되지 않는다는 건데 콜백 안에서 인자로 받지 않으면 인자로 가져올 수 없음.</li>\n<li>suspend함수를 쓰면 여기 만들어진 지역 변수가 이 모든 비동기로직이 한꺼번에 공유되기 때문에 손쉽게 클로저에 도움받지 않고 동기로직처럼 짤 수 있다.</li>\n</ul>\n<h3 id=\"2feelings\" style=\"position:relative;\"><a href=\"#2feelings\" aria-label=\"2feelings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.Feelings</h3>\n<ul>\n<li>코틀린 코루틴에 대해서 정말 4일 전까지만 해도 영상을 듣거나 책을 읽어도 이해를 하지 못했는데, 영상을 여러번 돌려보고 하나하나 무슨말을 하는지 따져가면서 반복하다 보니 눈에 들어오기 시작했다.</li>\n<li>오늘 알고리즘 문제를 풀면서 수학문제를 만났는데, 정말 알고리즘 문제를 다양하게 많이 풀어서 어떤 유형의 수학문제들이 나오는지 익히고 수학 공부가 필요함을 느꼈다.</li>\n</ul>\n<h3 id=\"3findings\" style=\"position:relative;\"><a href=\"#3findings\" aria-label=\"3findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.Findings</h3>\n<ul>\n<li>java의 future는 isCompleted를 while문으로 사용한다면 sync nonblocking이고 future.get으로 사용한다면 block async 이다. 전자는 future.isCompleted를 계속해서 요청해서, 백그라운드 스레드가 처리됬는지 확인하고, future.get 은 callback과 비슷한 놈이다. async로 요청을 하지만, 실행한 함수를 블로킹 걸고 끝나면 제어권을 실행함수로 넘겨주면서 콜백으로 get에 원하는 값이 존재하도록 하기 때문이다.</li>\n<li>오늘은 sync async block non-blocking 에 대해서 더 공부를 할 수 있었다.</li>\n<li>java의 completedFuture는 async nonblocking 방식이다. 자바스크립트의 promise와 유사한데 반제어 상태로 async non-blocking 방식을 구현한다. completedFuture를 사용하면 백그라운드는 실행되고 제어권도 실행한 함수로 돌아온다. 그래서 뒤에 코드를 계속해서 작성할 수 있다. 그리고 이후에 completedFuture에 접근을 할 경우, 백그라운드 실행이 완료 됬다면, 값을 반환하고, 완료되지 않았다면, 그 자리에서 기다리는 방식이다.</li>\n<li>kotlin 에서 operator로 getValue와 setValue를 넣어준다면 그것은 by로 delegate 한것과 동일하다.</li>\n<li>by로 deligate를 할 경우에, 그냥 a.b를 부를경우 b를 getValue로 가져오고 a.b = 1 을 할 경우 setValue로 값을 설정한다. 그래서 이 두 오퍼레이터에 커스텀을 해서 처리할 수가 있다.</li>\n</ul>","frontmatter":{"title":"코틀린 코드스피츠 continuation & cps 녹취록","date":null}}},"pageContext":{"slug":"/study/kotlin continuation & cps/","previous":{"fields":{"slug":"/study/관계형 데이터베이스 실전 입문 1장/"},"frontmatter":{"title":"관계형 데이터베이스 실전 입문 1장","category":"study"}},"next":{"fields":{"slug":"/study/java의 statement, expression, block/"},"frontmatter":{"title":"java의 expression, statement, block","category":"study"}}}},"staticQueryHashes":["3128451518","96099027"]}