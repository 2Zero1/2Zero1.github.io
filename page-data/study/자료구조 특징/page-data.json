{"componentChunkName":"component---src-templates-blog-post-js","path":"/study/자료구조 특징/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"252a3644-6e40-5014-af20-7e0ee5f95b29","excerpt":"c언어로 작성된 프로그램은 세가기 종류의 영역을 가진다. 전역변수나 정적 변수등이 저장되는 static memory 지역 변수가 저장되는 automatic memory free store static memory는 프로그램이 실행하면서 프로그램에서 사용될 전역 변수/정적 변수를 메모리에 할당한 후 프로그램이 종료될 때 해제하는 영역이다. 자동 메모리는 스택 구조로 이루어져 있어 이곳에 저장된 변수는 코드 블록이 종료됨에 따라 메모리에서 없어진다.\nfree store는 automatic memory…","html":"<p>c언어로 작성된 프로그램은 세가기 종류의 영역을 가진다.</p>\n<ol>\n<li>전역변수나 정적 변수등이 저장되는 static memory</li>\n<li>지역 변수가 저장되는 automatic memory</li>\n<li>free store</li>\n</ol>\n<p>static memory는 프로그램이 실행하면서 프로그램에서 사용될 전역 변수/정적 변수를 메모리에 할당한 후 프로그램이 종료될 때 해제하는 영역이다.</p>\n<p>자동 메모리는 스택 구조로 이루어져 있어 이곳에 저장된 변수는 코드 블록이 종료됨에 따라 메모리에서 없어진다.\nfree store는 automatic memory와 달리 프로그래머가 직접 메모리를 관리하는 메모리 영역이다. 그래서 자유롭게 메모리를 할당해서 사용할 수 있지만 그 메모리를 안전하게 해제해야한다.</p>\n<p>Token\n텍스트 분석에서의 토큰은 ‘최소 단위의 기호 또는 단어’를 말한다.</p>\n<h2 id=\"list리스트\" style=\"position:relative;\"><a href=\"#list%EB%A6%AC%EC%8A%A4%ED%8A%B8\" aria-label=\"list리스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>List(리스트)</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 배열처럼 데이터 집합을 보관하는 기능을 가지면서도 한편으로는 배열과는 달리 유연하게 크기를 바꿀 수 있는 자료구조이다.\n- 노드의 생성/소멸, 추가, 삭제, 삽입은 링크드 리스트 자료구조를 구축하기 위한 연산이고, 리스트 탐색은 구축되어 있는 링크드 리스트의 데이터를 활용하기 위한 연산이다.\n- pros&amp;cons\n  - pros\n    1. 새로운 노드의 추가/삽입/삭제가 쉽고 빠르다.(삭제 또는 삽입을 하기 위해선 최대 n번의 계산이 필요한데?)\n  - cons\n    1. 다음 노드를 가리키려는 포인터 때문에 각 노드마다 4byte의 메모리가 추가로 필요하다.\n    2. 특정 위치에 있는 노드를 얻는데 비용이 크며 속도도 느리다.(탐색). 노드의 개수가 n이라면 최악의 경우 n회의 노드 탐색 루프를 실행해야 특정 위치에 있는 노드를 찾을 수 있다.\n\n- 따라서 링크드 리스트가 사용되기에 적합한 곳은 레코드의 추가/삽입/삭제가 잦고 조회는 드문곳이다.\n- doubly linked list\n  - 위의 singly linked list의 탐색 기능을 개선한 자료구조이다.\n  - head와 tail을 알고 있어 양방향 탐색이 가능하다. 그래서 맨 마지막에 있는 데이터를 처음부터 찾을 필요가 없다.\n- 환형 링크드 리스트\n  - 테일의 다음 노드 포인터가 헤드를 가리키고 헤드의 이전 노드가 테일을 가리키게 하는 리스트(doubly linked list일 경우)\n  - 테일에 접근하는 비용이 거의 없는것이나 다름 없을 정도로 작아져 리스트의 마지막에 넣는 함수인 append 성능을 개선시킬 수 있고, 뒤에서부터 노드를 찾아 나가는 노드 탐색 루틴을 구현할 수도 있다.</code></pre></div>\n<h2 id=\"stack\" style=\"position:relative;\"><a href=\"#stack\" aria-label=\"stack permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>stack</h2>\n<ul>\n<li>First In, Last Out</li>\n<li>\n<p>오퍼레이션 종류</p>\n<ol>\n<li>push</li>\n<li>pop</li>\n</ol>\n</li>\n<li>\n<p>종류</p>\n<ol>\n<li>배열을 이용한 스택</li>\n<li>공적으로 스택의 용량을 조절하기 어렵지만 구현이 간단하다.</li>\n<li>리스트를 이용한 스택</li>\n<li>스택의 용량에 제한을 두지 않아도 된다.</li>\n</ol>\n</li>\n<li>\n<p>사용 예</p>\n<ol>\n<li>reverse polish Notation</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"queue\" style=\"position:relative;\"><a href=\"#queue\" aria-label=\"queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>queue</h2>\n<ul>\n<li>queue는 데이터 입력이 폭주할때 먼저 입력 받은 데이터의 처리가 끝나지 않았는데 그 뒤에 새로운 데이터가 마구 입력되면 그 데이터들은 보관할 장소가 따로 없으므로 버려야 한다. 이럴때 밀려드는 데이터를 보관할 장소로 큐가 필요하다.</li>\n<li>buffer와 비슷하다.</li>\n<li>First In First Out 의 특징을 갖고 있다.</li>\n<li>\n<p>순환큐</p>\n<ul>\n<li>큐를 배열로 구현하면 dequeue를 할 경우 맨 앞의 빈자리를 채우기 위해 뒤의 요소들을 모두 옮겨야 되는 문제가 발생한다. 그래서 전단을 가리키는 변수를 도입해서, 배열 내의 요소를 옮기는 대신 변경된 전단의 위치만 관리한다. 또 후단을 가리키는 변수도 도입해서 삽입이 일어날 때마다 변경되는 후단의 위치를 관리한다.</li>\n<li>하지만 위에서 말한 큐 또한 몇번의 dequeue로 전단과 후단이 가까워지고 후단이 들어갈 공간이 몇개 남지 않은 경우, 후단이 배열의 앞에서 다시 시작하도록 만들 수 있다.</li>\n<li>여기까지 한 것으론 순환큐가 가득차있는 상태와 빈 상태를 구분할 수 없다. 둘다 같은 요소를 가리킬 것이기 때문이다. 필요한 배열 요소 개수 + 1 개를 만들어 놓고 후단이 실제 후단에 1을 더한 값을 가지게 한다.</li>\n<li>그래서 큐가 비어있을땐 전단과 후단이 같은곳을 가리키고, 큐가 차있을땐 후단이 전단보다 -1 작은 값을 갖게 된다.</li>\n</ul>\n</li>\n<li>\n<p>링크드 큐</p>\n<ul>\n<li>순환큐는 개념도 복잡하고, 구현도 쉽지 않다.</li>\n<li>링크드 큐는 비교적 단순하다. 하지만 성능은 순환큐가 빠르다. 노드를 생성하고 삭제하기 위해 malloc()을 호추할 필요가 없기 때문이다.</li>\n<li>큐의 크기가 예측가능하고 고성능이 필요한 버퍼와 같은 사례에서는 링크드 큐보다는 순환 큐가 더 적절하다.</li>\n<li>링크드 큐는 가득차있는 상태인지 확인할 필요가 없다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"tree\" style=\"position:relative;\"><a href=\"#tree\" aria-label=\"tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TREE</h2>\n<p>조직도 같은 계층적인 데이터를 표현하는데 사용되고, 수식을 표현할때도 사용된다. 또한 집합을 나타내는 데 사용되며, 심지어는 데이터의 탐색을 위한 트리도 있다.</p>\n<h3 id=\"사용-예\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9-%EC%98%88\" aria-label=\"사용 예 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용 예</h3>\n<ol>\n<li>운영체제의 파일 시스템</li>\n<li>HTML이나 XML문서를 다룰떄 사용하는 DOM(Document Object Model)</li>\n<li>검색 엔진이나 데이터베이스(탐색 트리)</li>\n</ol>\n<h3 id=\"구성요소\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C\" aria-label=\"구성요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구성요소</h3>\n<ol>\n<li>root : 트리의 가장 위에 있는 노드</li>\n<li>branch : 루트와 잎 사이에 있는 모든 노드</li>\n<li>leaf : 끝에 있으며 단말(Terminal)노드라고도 함.</li>\n</ol>\n<h3 id=\"관계\" style=\"position:relative;\"><a href=\"#%EA%B4%80%EA%B3%84\" aria-label=\"관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>관계</h3>\n<ol>\n<li>parent: 노드의 부모를 가리킴</li>\n<li>children: 노드의 자식을 가리킴</li>\n<li>sibling: 같은 부모에 있는 node들을 가리킴</li>\n</ol>\n<h3 id=\"용어\" style=\"position:relative;\"><a href=\"#%EC%9A%A9%EC%96%B4\" aria-label=\"용어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>용어</h3>\n<ol>\n<li>path: 트리에서 경로는 한 노드에서부터 다른 한 노드까지 이르는 길 사이에 놓여있는 노드들의 순서이다.(a -> b -> c)</li>\n<li>length: 그저 출발 노드에서 목적지 까지 거쳐야 하는 노드의 개수를 말한다.(B -> D -> F 경로의 길이는 2가 된다.)</li>\n<li>depth: 루트 노드에서 해당 노드까지의 경로의 길이를 뜻한다.(length와의 차이가 뭘까 ?)</li>\n<li>level: 깊이가 같은 노드들의 집합을 일컫는 말이다.</li>\n<li>height: 루트에서 가장 깊은곳에 있는 잎노드 까지의 깊이를 뜻한다.</li>\n<li>Degree(차수): 노드의 자식 노드 개수, 트리의 차수는 트리내에 있는 노드들 가운데 자식 노드가 가장 많은 노드의 차수를 말한다.</li>\n</ol>\n<h3 id=\"트리의-표현-방법\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%A6%AC%EC%9D%98-%ED%91%9C%ED%98%84-%EB%B0%A9%EB%B2%95\" aria-label=\"트리의 표현 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트리의 표현 방법</h3>\n<ol>\n<li>Nested parenthesis(중첩된 괄호): 같은 레벨들의 노드들을 괄호로 같이 묶어 표현하는 방법이다. 이방법은 읽기 다소 어렵지만 트리를 하나의 공식처럼 표현할 수 있는 장점이 있다.</li>\n<li>Nested Set(중첩된 집합): 트리가 하위 트리의 집합이라는 관계를 잘 표현할 수 있다.</li>\n<li>Indentation(들여쓰기): 계층적인 특징을 잘 나타내며, 윈도우 탐색기의 폴더 트리가 들여쓰기로 표현한 트리의 좋은 예이다.</li>\n</ol>\n<h3 id=\"노드-표현하기\" style=\"position:relative;\"><a href=\"#%EB%85%B8%EB%93%9C-%ED%91%9C%ED%98%84%ED%95%98%EA%B8%B0\" aria-label=\"노드 표현하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드 표현하기</h3>\n<p>부모와 자식, 그리고 형제 노드를 서로 연결짓는 방법이다.</p>\n<ol>\n<li>\n<p>N-Link 표현법</p>\n<ul>\n<li>노드의 차수가 N이라는 의미이다.</li>\n<li>단점으로 차수가 0일 수도 수백 수만일수도 있다. 동적 메모리를 할당하여 가변 배열을 만들거나 링크드 리스트를 사용하면 해결할 수 있지만 너무 복잡해진다.</li>\n</ul>\n</li>\n<li>\n<p>LeftChild-Right Sibling표현법</p>\n<ul>\n<li>위에서 이야기한 N-Link 표현법의 문제를 해결해준다.</li>\n<li>이 방법을 이용하면 n개의 차수를 가진 노드의 표현이 두 개의 포인터, 왼쪽 자식-오른쪽 형제만으로 가능하다.</li>\n<li>이 표현법을 사용하는 트리에서 어느 한 노드의 모든 자식 노드를 얻으려면 일단 왼쪽 자식 노드에 대한 포인터만 있으면 된다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"이진-트리binary-tree\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%ACbinary-tree\" aria-label=\"이진 트리binary tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이진 트리(Binary tree)</h3>\n<p>모든 노드가 최대 2개의 자식을 가질 수 있는 트리이다. 일반 트리처럼 데이터를 담는 용도로는 사용하기가 곤란하지만, 역으로 이런 특별한 구조를 이용한 훌륭한 알고리즘들이 개발되어 있다. 수식을 트리 형태로 표현하여 계산해주는 수식 이진 트리(Expression Binary Tree)와 아주 빠른 데이터 검색을 가능케 하는 이진 탐색 트리(Binary Search Tree)가 있다.</p>\n<ol>\n<li>Full Binary Tree(포화 이진 트리)\n모든 노드들이 자식을 두명씩 가지며 잎 노드들이 모두 같은 깊이에 존재한다는것이 특징.</li>\n<li>Complete Binary Tree(완전 이진 트리)\n잎 노드들이 트리의 왼쪽부터 차곡차곡 채워진 것이 특징입니다.</li>\n</ol>\n<p>이진 트리는 일반 트리처럼 나무 모양의 자료를 담기 위한 자료구조가 아니라 컴파일러나 검색 등에 사용되는 특수 구조이다. 특히 이진 트리를 이용한 검색에서는 높은 성능을 위해 트리의 노드들을 가능한 한 ‘완전한’ 모습으로 배치하는것이 필수이다.</p>\n<p>비슷한 맥락의 이진트리의 상태를 분류하는 용어</p>\n<ol>\n<li>높이 균형 트리(Height Balanced Tree)\n루트 노드를 기준으로 왼쪽 하위 트리와 오른쪽 하위 트리의 높이가 1 이상 차이나지 않는 이진 트리를 일컫는 말.</li>\n<li>완전 높이 균형 트리(Completely Height Balanced Tree)\n완전 높이 균형 트리는 루트 노드를 기준으로 왼쪽 하위 트리와 오른쪽 하위 트리의 높이가 같은 이진 트리를 가리키는 말이다.</li>\n</ol>\n<h3 id=\"이진-트리의-순회traversal\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%88%9C%ED%9A%8Ctraversal\" aria-label=\"이진 트리의 순회traversal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이진 트리의 순회(Traversal)</h3>\n<p>순회는 트리 내의 노드들 사이를 돌아다니는 것을 말한다. 순회는 몇 가지 규칙에 근거해서 이진 트리 내부를 돌아다니며 효율적인 방법으로 원하는 데이터에 접근할 수 있는 방법을 제공한다.</p>\n<ol>\n<li>\n<p>Preorder Traversal(전위 순위)</p>\n<ul>\n<li>루트 노드부터 잎 노드까지 아래 방향으로 방문한다.</li>\n</ul>\n</li>\n<li>\n<p>Inorder Traversal(중위 순위)</p>\n<ul>\n<li>왼쪽 하위 트리부터 루트를 거쳐 오른쪽 하위 트리방향으로 방문한다.</li>\n</ul>\n</li>\n<li>\n<p>Postorder Traveral(후위 순위)</p>\n<ul>\n<li>왼쪽 하위트리 오른쪽 하위 트리를 거쳐 루트를 방문한다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"수식-트리expression-binary-tree\" style=\"position:relative;\"><a href=\"#%EC%88%98%EC%8B%9D-%ED%8A%B8%EB%A6%ACexpression-binary-tree\" aria-label=\"수식 트리expression binary tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수식 트리(Expression Binary Tree)</h3>\n<ol>\n<li>피연산자는 잎 노드이다.</li>\n<li>연산자는 루트 노드, 또는 가지 노드이다.</li>\n<li>피연산자는 수일수로 있고 또 다른 식일 수도 있다.</li>\n</ol>\n<h3 id=\"분리-집합disjoint-set\" style=\"position:relative;\"><a href=\"#%EB%B6%84%EB%A6%AC-%EC%A7%91%ED%95%A9disjoint-set\" aria-label=\"분리 집합disjoint set permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분리 집합(Disjoint Set)</h3>","frontmatter":{"title":"자료구조 특징","date":"December 04, 2019"}}},"pageContext":{"slug":"/study/자료구조 특징/","previous":{"fields":{"slug":"/til/2019-11-29/"},"frontmatter":{"title":"2019-11-29 TIL","category":"TIL"}},"next":{"fields":{"slug":"/study/면접 질문 정리/"},"frontmatter":{"title":"면접 질문","category":"study"}}}},"staticQueryHashes":["3128451518","96099027"]}