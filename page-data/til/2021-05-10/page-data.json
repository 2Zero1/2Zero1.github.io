{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/2021-05-10/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"6059aaf9-1d5b-5b7d-a397-e03d225b2056","excerpt":"fact object 2강 예제를 가지고 훈련하였다. 오브젝트 5강을 읽고 정리했다. feelings 지금 오브젝트와 tdd로 배우는 oop 책을 읽고 있는데 두 책 모두 쉽지 않은 책이라 진도 나가기가 쉽지 않다 .. 다음번엔 나한태 어려운 책 한권과 비교적 쉬운 책으로 선택해야겠다. 나는 목표기한까지 맞추다가 내 페이스를 자주 잃곤한다. finding object…","html":"<ol>\n<li>\n<p>fact</p>\n<ul>\n<li>object 2강 예제를 가지고 훈련하였다.</li>\n<li>오브젝트 5강을 읽고 정리했다.</li>\n</ul>\n</li>\n<li>\n<p>feelings</p>\n<ul>\n<li>지금 오브젝트와 tdd로 배우는 oop 책을 읽고 있는데 두 책 모두 쉽지 않은 책이라 진도 나가기가 쉽지 않다 .. 다음번엔 나한태 어려운 책 한권과 비교적 쉬운 책으로 선택해야겠다.</li>\n<li>나는 목표기한까지 맞추다가 내 페이스를 자주 잃곤한다.</li>\n</ul>\n</li>\n<li>\n<p>finding</p>\n<ul>\n<li>\n<p>object 5장 책임 할당하기</p>\n<ol>\n<li>메시지는 클라이언트의 의도를 표현한다.</li>\n<li>클라이언트는 어떤 객체가 메시지를 수신할지 알지 못하고 임의의 객체가 수신할 것이라고 알고 자신의 의도를 표현한 메시지를 전송한다. 그리고 메시지를 수신하기로 결정된 객체는 메시지를 처리할 ‘책임’을 할당 받게된다.</li>\n<li>메시지 송신자는 메시지 수신자에 대한 어떤 가정도 할 수 없으며 전송자 관점에서 메시지 수신자가 깔끔하게 캡슐화 된다.</li>\n<li>\n<p>grasp pattern(General Responsibility Assignment Software Patteren)</p>\n<ul>\n<li>일반적인 책임 할당을 위한 소프트웨어 패턴</li>\n<li>\n<p>Information Expert</p>\n<ul>\n<li>수행할 정보를 알고 있는 객체에게 책임을 할당</li>\n<li>위의 정보는 데이터와 다르며 책임을 수행하는 객체가 정보를 알고 있다고 해서 그 정보를 저장하고 있을 필요는 없다. 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수도 있다. 어떤 방식이건 정보 전문가가 데이터를 반드시 저장하고 있을 필요는 없다.</li>\n<li>하지만 객체는 행동(책임)으로 인해 정해지는데 모순이 발생함. 결국 코드를 작성하고 공통점을 찾다보면 그런 책임을 갖게될 객체를 찾고 코드를 변경하는 과정에서 책임을 가질 진짜 객체를 찾을 수 있음.</li>\n</ul>\n</li>\n<li>\n<p>Creator</p>\n<ul>\n<li>객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다.</li>\n<li>\n<p>조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라.</p>\n<ol>\n<li>B가 A 객체를 포함하거나 참조한다.</li>\n<li>B가 A 객체를 기록한다.(사용한다와 일치)</li>\n<li>B가 A 객체를 긴밀하게 사용한다.</li>\n<li>B가 A 객체를 초기화하는 데 필요한 데이터를 갖는다.(이 경우 B는 Information Expert다.)</li>\n</ol>\n</li>\n<li>어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.</li>\n<li>이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않으며 Creator 패턴은 이미 존재하는 객체 사이의 관계를 이용하기 때문에 설계가 낮은 결합도를 유지할 수 있음.(p.145)</li>\n</ul>\n</li>\n<li>Controller</li>\n<li>\n<p>Low Coupling</p>\n<ul>\n<li>coupling(결합도)는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖는지 나타내는 척도.</li>\n<li>낮은 결합도는 모든 설계 결정에서 염두해야하는 원리이다. 낮은 결합도는 항상 응집도 보다 높은 우선순위로 둬야 하며 이유는 응집도는 변화 추가시 어쩔 수 없이 변화되기 때문이다.(p.143 예제를 참고하면 응집도와 결합도 사이의 trade off에서 low coupling를 우선순위로 두고있는걸 볼 수 있음.)</li>\n</ul>\n</li>\n<li>\n<p>High Cohesion</p>\n<ul>\n<li>cohesion(응집도)는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 낮은 응집도를 갖는다.</li>\n<li>\n<p>low cohesion 진단법</p>\n<ol>\n<li>클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은것. 변경의 이유를 기준으로 클래스를 분리해야함.</li>\n<li>클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화 하고 있다면 응집도가 낮은 것임. 초기화 되는 속성의 그룹을 기준으로 클래스를 분리</li>\n<li>메서드 그룹이 속성을 사용하는지 여부로 나뉜다면 응집도가 낮은것이다. 이들 그룹을 기준으로 클래스를 분리.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>Polymorphism</p>\n<ul>\n<li>객체의 타입에 따라 변하는 로직이 있을 경우 변하는 로직을 담당할 책임은 타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당한다.</li>\n<li>객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당</li>\n<li>Polymorphism 패턴은 객체의 타입을 검사해서 타입에 따라 여러 대안을 수행하는 조건적인 논리(if 문 같은)를 사용하지 말라고 경고함.</li>\n</ul>\n</li>\n<li>Pure Fabrication</li>\n<li>Indirection</li>\n<li>\n<p>Protected Variations</p>\n<ul>\n<li>변화가 예상되는 불안정한 지점들을 식별하고 인터페이스를 통해 책임을 할당</li>\n<li>설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화 하라(gof94)는 Protected Variation 패턴의 본질을 잘 설명해준다.</li>\n<li>Protected variations 패턴은 책임 할당의 관점에서 캡슐화를 설명한 것이다.</li>\n<li>Protected variations 패턴을 이용해 타입의 종류를 안정적인 인터페이스 뒤로 캡슐화 할 수 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>변경에 취약한 클래스란 코드를 수정해야하는 이유를 하나 이상 가지는 클래스이다.</li>\n<li>응집도가 낮다는 것은 서로 연관성이 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져 있다는 것을 의미한다. 따라서 낮은 응집도가 초래하는 문제를 해결하기 위해선 변경의 이유에 따라 클래스를 분리해야한다.</li>\n<li>서로 다른 이유로 변경되는 메서드를 갖는 클래스는 응집도가 낮다.</li>\n<li>\n<p>변경의 이유가 하나 이상인 클래스를 찾는 방법</p>\n<ol>\n<li>\n<p>인스턴스 변수가 초기화 되는 시점을 확인한다. 응집도가 높다면 모든 속성을 함께 초기화 하며, 응집도가 낮다면 속성 일부만 초기화 하고 일부는 초기화 하지 않는 상태로 남긴다.</p>\n<ul>\n<li>해결 : 클래스의 속성이 다른 시점에 초기화되거나 일부만 사용된다는 것은 응집도가 낮다는 증거며 함께 초기화 되는 속성을 기준으로 코드를 분리해야한다.</li>\n</ul>\n</li>\n<li>\n<p>메서드들이 인스턴스 변수를 사용하는 방식을 살펴보고 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도가 높다는 것이고, 반면 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다.</p>\n<ul>\n<li>해결 : 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야한다.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>변경에 대비할 수 있는 방법으로 첫번째는 이해하고 수정하기 쉽게 최대한 단순히 설계하는것이고, 두번째로 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것이다.</li>\n<li>객체지향 프로그래밍이 어렵다면 procedure 지향으로 먼저 작성한 후에 oop코드로 변경한다.</li>\n<li>\n<p>긴 메서드의 부정적인 영향</p>\n<ul>\n<li>어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 전체적으로 이해하는 데 너무 많은 시간이 걸린다.</li>\n<li>하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.</li>\n<li>메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다.</li>\n<li>로직의 일부반 재사용하는 것이 불가능하다.</li>\n<li>코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것뿐이므로 코드 중복을 초래한다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>Future Action Plan</p>\n<ul>\n<li>처음에 잠깐 느려도 괜찬으니 내 페이스대로 하자</li>\n<li>내일은 오브젝트 6장을 20페이지 읽는다.</li>\n<li>리액트 page 부분 리팩터링을 진행한다.</li>\n<li>tdd로 배우는 oop 책을 읽는다.</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"2021-05-10 TIL","date":"May 10, 2021"}}},"pageContext":{"slug":"/til/2021-05-10/","previous":{"fields":{"slug":"/til/2021-05-09/"},"frontmatter":{"title":"2021-05 주차 회고","category":"TIL"}},"next":{"fields":{"slug":"/study/하루3분 네트워크5/"},"frontmatter":{"title":"하루 3분 네트워크 스터디 5","category":"study"}}}},"staticQueryHashes":["3128451518","96099027"]}