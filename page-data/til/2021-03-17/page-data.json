{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/2021-03-17/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"c7c8d880-2383-5273-8d52-83f712483f74","excerpt":"fact 강의 따라치기 운동을 했다. 프로 자바스크립트 테크닉 책을 읽고 따라쳤다. feelings 운동을 열심히 하니 머리가 맑아져서 날 통제하고 있다는 느낌이 더 많이 든다. 이전보다 기분이 많이 좋아졌다. 자바스크립트 책을 읽고 있는데 이전과 다르게 너무 재미있다. 소설책 읽는 느낌이 든다. finding 코드숨 useEffect…","html":"<ol>\n<li>\n<p>fact</p>\n<ul>\n<li>강의 따라치기</li>\n<li>운동을 했다.</li>\n<li>프로 자바스크립트 테크닉 책을 읽고 따라쳤다.</li>\n</ul>\n</li>\n<li>\n<p>feelings</p>\n<ul>\n<li>운동을 열심히 하니 머리가 맑아져서 날 통제하고 있다는 느낌이 더 많이 든다.</li>\n<li>이전보다 기분이 많이 좋아졌다.</li>\n<li>자바스크립트 책을 읽고 있는데 이전과 다르게 너무 재미있다. 소설책 읽는 느낌이 든다.</li>\n</ul>\n</li>\n<li>\n<p>finding</p>\n<ul>\n<li>\n<p>코드숨</p>\n<ul>\n<li>useEffect : 렌더 될때마다 인자로 들어간 함수가 실행되며, 두번째 인자인 배열에 들어간 변수가 변경됬는지 체크하여 변경되지 않았다면 첫번째 인자로 들어간 함수를 실행하지 않는다. 빈 배열이라면 맨 처음에만 한번 실행한다.</li>\n<li>useCallback : 리액트에서 컴포넌트를 memoization 할때 사용되며, 컴포넌트 내부에서 사용하는 함수가 매번 생성될때 똑같은 함수인데도 memo를 쓰지 않게 되는 현상을 방지하기 위해 사용됨. 두번째 인자인 배열에 들어간 변수들이 변경된것을 확인하여 그들이 변경될 경우에만 함수가 실행 되도록 할 수 있음.</li>\n<li>react-toolkit</li>\n<li>action, actionCreator, reducer 모두를 slice 한곳에서 해결하게 해준다.</li>\n<li>createSlice({initstate, name, reducers})순으로 사용된다.</li>\n<li>redux-thunk를 자동으로 내포하고 있다.</li>\n<li>virtualDom</li>\n<li>React는 실제 DOM 과 virtualDom을 사용한다.</li>\n<li>실제 DOM 보다 virtualDom이 diffing이 빠르다.</li>\n<li>실제 dom과 일치되는 virtualDom을 가지며 virtualDom이 update될때 이전 버전의 virtualDom과 비교하여 diffing을 하며 변경된 부분만 실제 dom에서 변경한다.</li>\n</ul>\n</li>\n<li>\n<p>프로 자바스크립트 테크닉</p>\n<ul>\n<li>챕터 2 : 특징, 함수 및 객체</li>\n<li>\n<p>클로저</p>\n<ul>\n<li>클로저(closure)는 부모 함수가 이미 종료된 다음, 내부 함수가 외곽에서 둘러싸는 함수의 변수를 참조하는 수단이다.</li>\n<li>클로저는 선택된 방식으로만 접근할 수 있는 맥락(context)을 제공한다.(p23 2-9)</li>\n<li>함수 프로그래밍 언어 중에는 클로저를 사용하여 함수인자 몇 개를 하나로 줄여서 더 간단한 함수로 만드는 커링(currying)이라는 기법이 있다.(p23 2-10)</li>\n<li>js를 사용할 때 무심결에 전역 범위 내에 여분의 변수를 남겨 놓는데, 이것들은 다른 라이브러리와 상호작용하여 복잡한 문제를 일으 킨다. 하지만 자체적으로 실행하는 익명 함수를 사용하면 다른 코드에서 일반적인 전역 변수를 감출 수 있다.(p23 2-11)</li>\n<li>\n<p>클로저를 사용할때 생기는 문제 <strong>이 부분은 이해가 잘 안된다.</strong></p>\n<ul>\n<li>부모 함수 내에 존재하는 변수를 클로저로 참조할 수 있지만, 변수가 만들어졌을 당시의 값이 아니라 부모 함수 내에서 변수의 최종 값을 제공한다. 이런 상황은 for루프에서 보게 된다. (p24 2-12)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>함수 오버로드와 유형-확인</p>\n<ul>\n<li>전달되는 인자의 개수나 유형에 따라 다르게 동작하도록 하는것을 오버로드(overload)라고 한다.</li>\n<li>자바스크립트에서 제공되는 기능을 사용하여 오버로드를 구현할 수 있다.(p25 2-13)</li>\n<li>함수를 오버로드하기 위해선 <strong>인자의 갯수</strong> 와 <strong>인자의 유형</strong> 을 알아야 한다.</li>\n<li>\n<p>js 함수에 arguments라고 불리는 context 변수가 있는데 함수로 전달되는 모든 인자를 품는 유사 배열이다.</p>\n<ul>\n<li>배열의 protoType을 받지 않으며, push 또는 indexOf 같이 배열을 처리하는 함수를 갖지도 않는다.</li>\n<li>하지만 배열의 위치에 접근하고(a[2]), length 속성을 갖는다.</li>\n</ul>\n</li>\n<li>자바스크립트는 동적으로 유형이 정해지는 언어이다. <strong>이게 무슨 의미일까? 타입을 정해놓지 않아도 된다는 말일까 ? 타입을 정한 언어란 ? 차이는?</strong></li>\n<li>\n<p>객체의 타입을 확인할 수 있는 방법은 두가지이다.</p>\n<ul>\n<li>\n<p>typeof 연산자</p>\n<ul>\n<li>변수 내용의 유형을 나타내는 문자열을 반환한다.</li>\n<li>typeof의 장점은 테스트하는 변수의 실제 유형이 무엇인지 알 필요가 없다는 점이다.</li>\n<li>하지만 object나 array에 사용하면 ‘object’라고만 반환하여 구분할 수가 없기 때문에 instanceof를 같이 사용하면 된다.</li>\n</ul>\n</li>\n<li>\n<p>instanceof 연산자</p>\n<ul>\n<li>왼쪽 피연산자를 오른쪽 피연산자의 생성자와 비교하는 방법을 사용하며 boolean을 반환함</li>\n</ul>\n</li>\n<li>Object.isPrototypeOf() 함수 또한 유형을 판정하는데 도움이 된다.</li>\n<li>특별한 유형-검사 방법이 필요할땐 유형을 판정하는 맞춤식 함수를 만드는 것이 좋다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>객체</p>\n<ul>\n<li>객체는 자바스크립트의 기초이며 사실상 언어로 포함되어 있는 모든것이 객체다.</li>\n<li>가장 기본적인 단계로 볼 때 객체는 속성의 집합으로써 존재하며 다른언어에서 볼 수 있는 해시 구성체<strong>이게 뭐지? 무슨 말이야</strong>와 거의 같다.</li>\n<li>\n<p>객체 수정</p>\n<ul>\n<li>\n<p>자바스크립트는 기본적으로 언제든지 객체를 수정할 수 있고, 제어하는데 도움이 되는 세가지 방법을 갖는다.</p>\n<ul>\n<li>Object.preventExtensions()을 써서 객체에 새로운 속성이 추가되지 못하게 막을 수 있다. (use strict 모드에서 가능하다.)</li>\n<li>\n<p>Object.seal()을 쓰면 Object.preventExtensions()을 썼을때와 비슷하게 객체의 기능을 제한할 수 있다.</p>\n<ul>\n<li>하지만 속성은 지워지지도 않고 접근자(getter, Object.defineProperty())로 바뀌지 않는다(맥락상 속성이 추가가 안된다는 이야기 같음.). 하지만 쓸 수 있는 속성을 갱신하면 오류가 발생하진 않는다.</li>\n<li>하지만 이미 존재하는 속성을 갱신할 수 있다. a.data = 1처럼. 하지만 위의 접근자를 사용하면 에러가 발생한다.</li>\n</ul>\n</li>\n<li>\n<p>Object.freeze()는 세가지 방법중 가장 제약이 많다.</p>\n<ul>\n<li>일단 사용되면 객체는 고정되며 속성은 추가되거나 지워지거나 갱신되지 않는다.</li>\n<li>속성이 객체라면 갱신 가능하며 이런것을 shallow freeze라고 한다.</li>\n<li>객체를 완전히 골정하려면 그 값으로 객체를 포함하는 일체의 속성 또한 고정되어져야 한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>챕터 3 : 재활용하는 코드 만들기</li>\n<li>js는 protoType의 언어이며 js는 모든 것이 원형을 갖는다.</li>\n<li>객체지향 프로그래밍은 코드를 재활용하여 복제하는 노력을 제거하는 패턴을 제공한다.</li>\n<li>ECMASript는 protoType을 숨겨진 것으로 규정하고 참조한다.</li>\n<li>\n<p>두 가지 방법으로 접근할 수 있다.</p>\n<ul>\n<li>\n<p>비표준 <strong>proto</strong> 속성</p>\n<ul>\n<li>공식적으로 유형의 원형이 되었으며 이후 규칙에 따라 구현되는 어떤 것에서도 쓸 수 있게 되었다.</li>\n</ul>\n</li>\n<li>prototype 속성</li>\n</ul>\n</li>\n<li>어떤 유형에 대해서도 prototype 속성에 접근할 수 있다.</li>\n<li>js 핵심적인 유형은 모두 공개적인 prototype 속성을 갖는다.</li>\n<li>함수 생성자로 만들어진 임의의 자바스크립트 유형(타입)은 공개적인 protytype 속성도 갖디만 이런 유형(타입)의 인스턴스는 문자열이나 날짜 또는 무엇이든 간에 prototype 속성을 갖지 않는다. 왜냐면 prototype 속성은 인스턴스에선 사용할 수 없기 때문이다.</li>\n<li>js는 클래스가 아닌 객체로 인스턴스로 만들어질 수 있으며, 인스턴스 객체와 본체 객체 타입 간에는 prototype 속성으로 연결이 있다.</li>\n<li>js는 클래스를 갖지 않기 때문에 단순히 상호 간에 관계를 갖는 객체가 있으며 이것을 prototype chain이라고 한다.</li>\n<li>위의 관계를 behavior delegation이라고도 한다.</li>\n<li>prototype chain이란 behavior delegation을 뜻하며 연결고리상에 있는 다른 것도 behavior delegation할 수 있게 해주고, 하면할수록 부가적으로 할 수 있는 일을 축적하게 된다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Future Action Plan</p>\n<ul>\n<li>내일 운동은 하체다</li>\n<li>프로젝트 기획을 한다.</li>\n<li>리액트 문서를 전체적으로 봐야겠다.</li>\n<li>내일은 7강 강의를 한번 더 봐야겠다.</li>\n<li>기획을 위해 이전 기수의 작품을 보고 내가 하고싶은 프로젝트를 리스트업 해야겠다.</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"2021-03-17 TIL","date":"March 17, 2021"}}},"pageContext":{"slug":"/til/2021-03-17/","previous":{"fields":{"slug":"/til/2021-03-16/"},"frontmatter":{"title":"2021-03-16 TIL","category":"TIL"}},"next":{"fields":{"slug":"/study/하루3분 네트워크5/"},"frontmatter":{"title":"하루 3분 네트워크 스터디 5","category":"study"}}}},"staticQueryHashes":["3128451518","96099027"]}