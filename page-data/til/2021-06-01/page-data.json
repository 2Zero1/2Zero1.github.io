{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/2021-06-01/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"5e449bb3-cbbd-5a99-b6ff-8a11b59e7d74","excerpt":"fact 오늘 면접을 2개 봤다. 오브젝트 3장을 읽었다. feelings 요즘 면접으로 인해 시간을 효율적으로 잘 못쓰고 있음을 느꼈다. finding…","html":"<ol>\n<li>\n<p>fact</p>\n<ul>\n<li>오늘 면접을 2개 봤다.</li>\n<li>오브젝트 3장을 읽었다.</li>\n</ul>\n</li>\n<li>\n<p>feelings</p>\n<ul>\n<li>요즘 면접으로 인해 시간을 효율적으로 잘 못쓰고 있음을 느꼈다.</li>\n</ul>\n</li>\n<li>\n<p>finding</p>\n<ul>\n<li>\n<p>3장 역할, 책임, 협력</p>\n<ul>\n<li>객체지향 패러다임 관점에서 핵심은 역할, 책임, 협력이다.</li>\n<li>객체지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 일어난다. 클래스와 상속은 객체들의 책임과 협력이 어느정도 자리를 잡은 후에 사용할 수 있는 구현 메커니즘이다.</li>\n<li>객체를 자율적으로 만드는 가장 기본적인 방법은 캡슐화다.</li>\n<li>자율적인 객체는 자신에게 할당된책임을 수행하던 중 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 전송해서 협력을 요청한다.</li>\n<li>협력을 설계하는 출발점은 시스템이 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보고 시스템의 책임을 완료하는데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰간다.</li>\n<li>\n<p>협력</p>\n<ul>\n<li>객체들이 어플의 기능을 구현하기 위해 수행하는 상호작용.</li>\n<li>객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다. 협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.</li>\n<li>객체의 행동을 결정하는 것이 협력이라면 상태를 결정하는 것은 행동이다. 객체의 상태는 그 객체가 행동을 수행하는데 필요한 정보가 무엇인지로 결정된다.</li>\n<li>객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정하며 협력은 객체를 설계하는데 필요한 일종의 context를 제공한다.</li>\n</ul>\n</li>\n<li>\n<p>책임</p>\n<ul>\n<li>객체가 협력에 참여하기 위해 수행(행동)하는 로직.</li>\n<li>책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로, 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다.</li>\n<li>\n<p>크레이그 라만은 객체의 책임을 크게 하는것과 아는것을 나눈다.</p>\n<ul>\n<li>객체는 자신이 맡은 책임을 수행하는데 필요한 정보를 알고 있을 책임이 있다. 또 객체는 자신이 할 수 없는 작업을 도와줄 객체를 알고 있을 책임이 있다. 어떤 책임을 수행하기 위해서는 그 책임을 수행하는 데 필요한 정보도 함께 알아야 할 책임이 있다는 것이다.</li>\n</ul>\n</li>\n<li>협력 안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다.</li>\n<li>자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다. 이를 Information expert패턴이라고 한다.</li>\n<li>객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택(이를 책임 주도 설계라 한다.)하는 반복적인 과정을 통해 이뤄진다. 이렇게 결정된 메시지는 퍼블릭 인터페이스를 구성한다.</li>\n<li>모든 책임을 정보 전문가에게 할당하는건 아니지만 그렇게 하는것만으로도 상태와 행동을 함께 가지는 자율적인 객체를 만들 가능성이 높아진다.</li>\n<li>메시지는 객체를 결정하고, 행동이 상태를 결정한다.</li>\n<li>\n<p>메시지가 객체를 선택하면 좋은 점</p>\n<ol>\n<li>객체가 최소한의 인터페이스를 갖는다. 필요한 메시지가 식별 될때까지 객체의 퍼블릭 인터페이스에 어떤것도 추가하지 않는다.</li>\n<li>객체는 충분히 추상적인 인터페이스를 갖는다. 인터페이스는 what을 표현하지 how를 표현하지 않는다. 무엇을 할지 초점을 맞추게된다.</li>\n</ol>\n</li>\n<li>얼마나 적절한 객체를 창조했느냐는 얼마나 적절한 책임을 할당했느냐에 달려있고, 책임이 얼마나 적절한지는 협력에 얼마나 적절한가에 달려있다.</li>\n<li>개별 객체의 상태와 행동이 아닌 기능 구현을 위한 협력에 초점을 맞춰야 응집도가 높고 결합도가 낮은 객체들을 만들 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>역할</p>\n<ul>\n<li>객체가 어떤 특정 협력 안에서 수행하는 책임의 집합을 역할이라고 한다. 또 객체를 바꿔 끼울 수 있는 슬롯이라고 볼수 있다.</li>\n<li>역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다.(다형성을 이용한 ocp를 달성)</li>\n<li>협력의 관점에서 추상클래스와 인터페이스는 구체 클래스들이 따라야 하는 책임의 집합을 서술한것이다.</li>\n<li>역할은 다양한 종류의 객체를 수용할 수 있는 일종의 슬롯이자 구체적인 객체들의 타입을 캡슐화하는 추상화이다.</li>\n<li>역할은 객체(구성 요소들을)를 추상화해서 객체 자체가 아닌 협력에 초점을 맞추게한다.</li>\n<li>협력을 구성하기 위해 역할에 적합한 객체가 선택되며, 객체는 클래스를 이용해 구현된다.</li>\n<li>\n<p>역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화로 볼 수 있다. 따라서 추상화가 가지는 두 가지 장점은 협력의 관점에서 역할에도 동일하게 적용될 수 있다.</p>\n<ol>\n<li>추상화의 첫번째 장점은 세부 사항에 억눌리지 않고도 상위 수준의 정책을 쉽고 간단하게 표현할 수 있다</li>\n<li>설계를 유연하게 만들 수 있다.(ocp)</li>\n</ol>\n</li>\n<li>협력이라는 문맥 안에서 역할은 특정한 협력에 참여해서 책임을 수행하는 객체의 일부다 역할은 오직 시스템의 문맥 안에서 무엇을 하는지에 의해서만 정의될 수 있다.</li>\n<li>객체는 다양한 역할을 가질 수 있고 특정한 협력 안에서는 일시적으로 오직 하나의 역할만이 보여진다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Future Action Plan</p>\n<ul>\n<li>꾸준하기</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"2021-06-01 TIL","date":"June 01, 2021"}}},"pageContext":{"slug":"/til/2021-06-01/","previous":{"fields":{"slug":"/study/오브젝트/2장/"},"frontmatter":{"title":"오브젝트 2장","category":"OOP"}},"next":{"fields":{"slug":"/study/그림으로 배우는 HTTP & Network Basic2/"},"frontmatter":{"title":"그림으로 배우는 HTTP & Network basic 2","category":"study"}}}},"staticQueryHashes":["3128451518","96099027"]}