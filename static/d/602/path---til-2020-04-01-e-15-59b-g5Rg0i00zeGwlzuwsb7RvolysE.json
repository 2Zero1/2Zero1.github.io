{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"dbaca4d0-4f1f-581b-a46f-e1c49e271c88","excerpt":"할 일 목록 논리학 공부하고 8개의 규칙을 정리한다. 양화 논리에 대해서 공부한다. DB 정리 하기 졸프와 OOSE 수업 프로젝트의 requirements를 세운다. 완료하지 못한 목록 졸프와 OOSE 수업 프로젝트의 requirements를 세운다. 완료 목록 입출력 공부 DB 정리 하기 논리학 공부하고 8개의 규칙을 정리한다. DB 관계형 데이터베이스 실전 입문 정리 1.SQL과 관계형 모델 SQL이란 SQL이란 관계형 데이터베이스(이하 RDB)에 질의를 하기 위한 언어이다. RDB…","html":"<h2 id=\"할-일-목록\"><a href=\"#%ED%95%A0-%EC%9D%BC-%EB%AA%A9%EB%A1%9D\" aria-label=\"할 일 목록 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>할 일 목록</h2>\n<ol>\n<li>논리학 공부하고 8개의 규칙을 정리한다.</li>\n<li>양화 논리에 대해서 공부한다.</li>\n<li>DB 정리 하기</li>\n<li>졸프와 OOSE 수업 프로젝트의 requirements를 세운다.</li>\n</ol>\n<h2 id=\"완료하지-못한-목록\"><a href=\"#%EC%99%84%EB%A3%8C%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%EB%AA%A9%EB%A1%9D\" aria-label=\"완료하지 못한 목록 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>완료하지 못한 목록</h2>\n<ol>\n<li>졸프와 OOSE 수업 프로젝트의 requirements를 세운다.</li>\n</ol>\n<h2 id=\"완료-목록\"><a href=\"#%EC%99%84%EB%A3%8C-%EB%AA%A9%EB%A1%9D\" aria-label=\"완료 목록 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>완료 목록</h2>\n<ul>\n<li>입출력 공부</li>\n<li>DB 정리 하기</li>\n<li>논리학 공부하고 8개의 규칙을 정리한다.</li>\n</ul>\n<h2 id=\"db-관계형-데이터베이스-실전-입문-정리\"><a href=\"#db-%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8B%A4%EC%A0%84-%EC%9E%85%EB%AC%B8-%EC%A0%95%EB%A6%AC\" aria-label=\"db 관계형 데이터베이스 실전 입문 정리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DB 관계형 데이터베이스 실전 입문 정리</h2>\n<h3 id=\"1sql과-관계형-모델\"><a href=\"#1sql%EA%B3%BC-%EA%B4%80%EA%B3%84%ED%98%95-%EB%AA%A8%EB%8D%B8\" aria-label=\"1sql과 관계형 모델 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.SQL과 관계형 모델</h3>\n<h4 id=\"sql이란\"><a href=\"#sql%EC%9D%B4%EB%9E%80\" aria-label=\"sql이란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL이란</h4>\n<p>SQL이란 관계형 데이터베이스(이하 RDB)에 질의를 하기 위한 언어이다.</p>\n<h5 id=\"rdb는-관계형-모델을-바르게-구현할수록-더욱-진가를-발휘한다\"><a href=\"#rdb%EB%8A%94-%EA%B4%80%EA%B3%84%ED%98%95-%EB%AA%A8%EB%8D%B8%EC%9D%84-%EB%B0%94%EB%A5%B4%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%95%A0%EC%88%98%EB%A1%9D-%EB%8D%94%EC%9A%B1-%EC%A7%84%EA%B0%80%EB%A5%BC-%EB%B0%9C%ED%9C%98%ED%95%9C%EB%8B%A4\" aria-label=\"rdb는 관계형 모델을 바르게 구현할수록 더욱 진가를 발휘한다 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RDB는 관계형 모델을 바르게 구현할수록 더욱 진가를 발휘한다</h5>\n<p>SQL은 관계형 모델을 기반으로 한 질의 언어이지만 관계형 모델을 충실하게 재현하지는 않는다. SQL은 매우 유연성이 높게 설계된 언어이므로 관계형 모델에 맞게 사용할 수도 있고, 반대로 전혀 다르게 사용할 수도 있다. 하지만 <strong><em>SQL은 관계형 모델을 기반으로 설계돼 있으므로 관계형 모델에 따른 연산이 가장 적합하다.</em></strong></p>\n<h4 id=\"관계형-모델\"><a href=\"#%EA%B4%80%EA%B3%84%ED%98%95-%EB%AA%A8%EB%8D%B8\" aria-label=\"관계형 모델 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>관계형 모델</h4>\n<p>관계형 모델은 실제 세계의 데이터를 <strong>관계</strong> 라는 개념을 사용해 표현한 데이터 모델이다.</p>\n<p>관계형 모델이 나타내는 데이터 모델은 설계의 의미가 아니고 “데이터를 어떻게 표현할까” 라는 개념의 이미다. \"\"ㅁㅁ라는 개념을 사용해 데이터를 표현해주세요\"\" 라고 정하는 것이 데이터 모델이며 관계형 모델은 그중 하나라고 할 수 있다.</p>\n<p>KVS(Key-Value Store)처럼 키와 그에 해당하는 값의 형태로 데이터를 표현하는 것도 데이터 모델의 하나다.</p>\n<p>관계형 모델을 이해하는 데 가장 중요한 개념이 관계(릴레이션)다.</p>\n<h5 id=\"릴레이션관계의-정리\"><a href=\"#%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98%EA%B4%80%EA%B3%84%EC%9D%98-%EC%A0%95%EB%A6%AC\" aria-label=\"릴레이션관계의 정리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>릴레이션(관계)의 정리</h5>\n<p>SQL에 있어 릴레이션에 해당하는 것은 테이블이다.</p>\n<p>관계형 모델에서 릴레이션은 제목(Heading)과 본체(Body)로 구성되 있으며, 제목은 속성(Attribute)이 n개 모인 집합이며, 이 속성은 이름과 데이터 형으로 되어 있다. 본체는 속성값의 집합인 행 또는 영어로 말하면 튜플(tuple)의 집합이다.</p>\n<p>튜플에 포함된 속성값은 이름과 데이터 형이 제목에서 지정한 것과 서로 일치하지 않으면 안 된다.</p>\n<p>릴레이션이란 튜플의 집합이고, 튜플은 모두 같은 n개의 속성값의 집합으로, 데이터 구성이 서로 같다.</p>\n<p>튜플의 집합은 릴레이션의 본체이며 원래 의미는 본체와 제목의 쌍을 가진 관계라고도 한다.</p>\n<p>튜플과 속성을 SQL 에서는 각각 행(row)과 열(column)이라고 한다.</p>\n<h5 id=\"집합이란\"><a href=\"#%EC%A7%91%ED%95%A9%EC%9D%B4%EB%9E%80\" aria-label=\"집합이란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>집합이란</h5>\n<p>집합은 수학에서 사용되는 개념으로 물건의 모임을 표현하는 개념이다. 집합에 포함된 각 물건을 요소나 원소(Element)라고 한다. 요소에는 특별한 제약이 없으며 물건의 모임을 처리하기 위한 범용적인 구조로써 집합을 사용할 수 있다.</p>\n<p>집합의 요소는 어떤 성질이든 상관 없지만 몇가지 조건을 충족해야한다.</p>\n<ol>\n<li>\n<p>어떤 요소가 집합에 포함돼 있는지 불정확한 요소 없이 판정할 수 있어야 한다.</p>\n<ul>\n<li>무엇인지 모르는 미지의 요소는 집ㅎ바에 포함될 수 없다.</li>\n</ul>\n</li>\n<li>집합의 요소가 중복돼서는 안 된다. 집합에서 중요한 것은 어떤 요소가 포함돼 있는가 아니냐는 점이다.</li>\n</ol>\n<p>집합의 요소는 더는 분해될 수 없다. e를 분해한 일부는 e와는 일치하지 않으므로 <code class=\"language-text\">e ∈ S</code>라는 판정에 아무런 영향을 미치지 않는다.</p>\n<p>관계형 모델은 집합론에 기인하는 데이터 모델이다. 집합이 무엇인지 이해하는 것이 관계형 모델을 이해하는데 있어서 중요하다.</p>\n<h5 id=\"관계형-모델과-null\"><a href=\"#%EA%B4%80%EA%B3%84%ED%98%95-%EB%AA%A8%EB%8D%B8%EA%B3%BC-null\" aria-label=\"관계형 모델과 null permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>관계형 모델과 NULL</h5>\n<p>집합에서 알 수 없는 것을 포함하지 않는 것은 집합의 한 종류인 릴레이션에 NULL을 포함할 수 없다는 의미다. NULL은 값이 아니고 요소가 무엇인지 모르는, 즉 알 수 없는 값임을 나타내는 표식이다.</p>\n<h5 id=\"유한-집합과-무한-집합\"><a href=\"#%EC%9C%A0%ED%95%9C-%EC%A7%91%ED%95%A9%EA%B3%BC-%EB%AC%B4%ED%95%9C-%EC%A7%91%ED%95%A9\" aria-label=\"유한 집합과 무한 집합 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유한 집합과 무한 집합</h5>\n<p>집합에는 유한집합과 무한집합이라는 종류가 있다. 관계형 모델이 다루는 것은 유한집합 뿐이다.</p>\n<h5 id=\"릴레이션의-연산\"><a href=\"#%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98%EC%9D%98-%EC%97%B0%EC%82%B0\" aria-label=\"릴레이션의 연산 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>릴레이션의 연산</h5>\n<p>단순하게 릴레이션으로 데이터를 표현하는 것만으로는 도움이 안되고, 데이터는 그에 대한 연산(또는 조작)과 세트로 사용될 때 의미가 있다.</p>\n<p>데이터를 릴레이션이라고 표현한다면 그에 대한 연산은 쿼리(질의)다. 관계형 모델은 릴레이션 단위로 다양한 연산을 사용해 질의를 수행하는 데이터 모델이다. 릴레이션을 사용한 연산을 수행하므로 관계형 모델이라고 부른다.</p>\n<p>릴레이션은 본질적으로 집합이며 그에 대한 연산도 집합론을 바탕으로 하고 있다. 릴레이션 내의 튜플이 모두 같은 구조, 즉 같은 이름, 같은 데이터형을 가지므로 일반적인 집합에는 없는 관계형 모델 특유의 연산이 많다.</p>\n<h5 id=\"대표적인-연산\"><a href=\"#%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-%EC%97%B0%EC%82%B0\" aria-label=\"대표적인 연산 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대표적인 연산</h5>\n<h6 id=\"제한restrict\"><a href=\"#%EC%A0%9C%ED%95%9Crestrict\" aria-label=\"제한restrict permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제한(Restrict)</h6>\n<p>제한은 어떤 릴레이션들 중에 특정 조건에 맞는 튜플을 포합한 릴레이션을 반환한다. 제한을 실행한 결과는 릴레이션의 부분집합이라고 할 수 있다.</p>\n<h6 id=\"프로젝션projection\"><a href=\"#%ED%94%84%EB%A1%9C%EC%A0%9D%EC%85%98projection\" aria-label=\"프로젝션projection permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로젝션(Projection)</h6>\n<p>프로젝션은 어떤 릴레이션에서 특정 속성만 포함하는 릴레이션을 반환한다. 어떤 릴레이션에서 특정 속성으로 프로젝션 하면 중복된 요소가 있을 경우 집합은 중복되는 요소는 포함할 수 없으므로 중복이 발생한 경우 같은 튜플로 간주한다.</p>\n<h6 id=\"확장extend\"><a href=\"#%ED%99%95%EC%9E%A5extend\" aria-label=\"확장extend permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장(Extend)</h6>\n<p>확장(Extend)은 프로젝션과는 반대로 속성을 늘리는 동작이다. 대부분 새로운 속성값은 기존의 속성값을 이용해 계산한다.</p>\n<h6 id=\"속성명-변경rename\"><a href=\"#%EC%86%8D%EC%84%B1%EB%AA%85-%EB%B3%80%EA%B2%BDrename\" aria-label=\"속성명 변경rename permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>속성명 변경(Rename)</h6>\n<p>속성명 변경(Rename)은 단순히 속성의 이름을 변경하는 동작이다. 실제로는 주로 확장한 속성에 대해 명칭을 부여할 때 사용한다.</p>\n<h6 id=\"합집합union\"><a href=\"#%ED%95%A9%EC%A7%91%ED%95%A9union\" aria-label=\"합집합union permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>합집합(Union)</h6>\n<p>합집합은 두 개의 릴레이션에 포함된 모든 튜플로 구성된 릴레이션(합집합)을 반환한다. 두 개의 릴레이션에 공통된 속성값이 포함됐다면 중복 값이 제거된 상태가 된다.</p>\n<h6 id=\"교집합intersect\"><a href=\"#%EA%B5%90%EC%A7%91%ED%95%A9intersect\" aria-label=\"교집합intersect permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교집합(Intersect)</h6>\n<p>교집합은 두 개의 릴레이션에 모두 포함된 릴레이션을 반환한다.</p>\n<h6 id=\"차집합difference\"><a href=\"#%EC%B0%A8%EC%A7%91%ED%95%A9difference\" aria-label=\"차집합difference permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>차집합(Difference)</h6>\n<p>차집합은 두 개의 릴레이션 중에 한쪽의 릴레이션에만 포함되어 있는 튜플로 구성된 릴레이션을 반환한다. 차집합은 어느 쪽의 릴레이션을 기준으로 정하는지에 따라 결과가 달라진다.</p>\n<h6 id=\"곱집합product\"><a href=\"#%EA%B3%B1%EC%A7%91%ED%95%A9product\" aria-label=\"곱집합product permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>곱집합(Product)</h6>\n<p>곱집합은 두 개의 릴레이션에 있는 튜플을 각각 조합한 릴레이션을 반환한다. 이때 릴레이션의 제목은 두 개의 릴레이션의 제목이 가진 속성을 전부 포함한다.</p>\n<h6 id=\"결합join\"><a href=\"#%EA%B2%B0%ED%95%A9join\" aria-label=\"결합join permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결합(Join)</h6>\n<p>결합은 공통된 속성을 가진 두 개의 릴레이션에서 공통된 속성값이 같은 튜플끼리 조합한 릴레이션을 반환한다.</p>\n<p>결과적으로 반환되는 튜플은 두 개의 릴레이션에서 공통된 속성에 관해 같은 값이 존재하는 것뿐이다. 즉 일치하지 않는 값이 존재하지 않는 튜플은 결과에서 제외된다. 이와 같은 형태의 결합을 SQL에서는 내부조인(INNER JOIN)이라고 한다.</p>\n<p>덧붙혀 교집합과 곱집합은 결합의 특수한 예다. 교집합은 두 개의 릴레이션에 포함되는 속성이 전부 공통인 경우이고 반대로 곱집하는 공통의 속성이 존재하지 않는 경우다.</p>\n<h5 id=\"요소에-null이-포함돼-있으면\"><a href=\"#%EC%9A%94%EC%86%8C%EC%97%90-null%EC%9D%B4-%ED%8F%AC%ED%95%A8%EB%8F%BC-%EC%9E%88%EC%9C%BC%EB%A9%B4\" aria-label=\"요소에 null이 포함돼 있으면 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요소에 NULL이 포함돼 있으면</h5>\n<p>만약 릴레이션에 NULL이 포함돼 있으면 관계형 모델은 성립하지 않는다. NULL은 값을 모르는 상태를 나타내는 표식이다. 따라서 NULL이 포함돼 있으면 릴레이션 연산 결과가 항상 같아지지 않는다.</p>\n<p><strong><em>NULL은 관계형 모델의 근본을 뒤집는 불안전한 요소다.</em></strong></p>\n<h5 id=\"클로저closure라는-성질\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80closure%EB%9D%BC%EB%8A%94-%EC%84%B1%EC%A7%88\" aria-label=\"클로저closure라는 성질 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클로저(closure)라는 성질</h5>\n<p><strong><em>관계형 모델에서 중요한 것은 릴레이션을 사용한 연산 결과가 릴레이션이 되는 것이다.</em></strong> 이처럼 입력과 출력이 같은 데이터 구조를 가진 성질을 클로저(폐쇄)라고 한다.</p>\n<p>이와같은 데이터 구조는 연산 결과를 새롭게 입력해 꼬리에 꼬리를 무는 것처럼 연산을 기술하여 복잡한 연산을 표현할 수 있다. 그렇기 때문에 연산 결과가 릴레이션이라면 그 결과를 다른 릴레이션과 조합해 연산할 수 있다.</p>\n<p>릴레이션의 연산만을 이용해 복잡한 연산을 표현할 수 있다는 점이 관계형 모델의 진면목이라고 할 수 있다.</p>\n<h5 id=\"관계형-모델의-데이터-형식\"><a href=\"#%EA%B4%80%EA%B3%84%ED%98%95-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%98%95%EC%8B%9D\" aria-label=\"관계형 모델의 데이터 형식 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>관계형 모델의 데이터 형식</h5>\n<p>데이터 형식이란 각 속성이 어떤 값을 가질 것인지를 말한다.</p>\n<p>관계형 모델 자신은 “어떤 데이터 형식을 사용해야 할까?” 라고 결정하지 않는다. 관계형 모델은 문자 그대로 <strong><em>모델</em></strong>이므로 <strong><em>어떻게 사용할 수 있는지</em></strong>가 정해져 있을 뿐 <strong><em>어떻게 사용해야 한다</em></strong>는 모델을 사용하는 응용 프로그램이 정해야 한다.</p>\n<h6 id=\"데이터-형식과-변수\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%98%95%EC%8B%9D%EA%B3%BC-%EB%B3%80%EC%88%98\" aria-label=\"데이터 형식과 변수 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 형식과 변수</h6>\n<p>변수란 값을 대입할 수 있는 그릇이다. 변수의 내용은 프로그램이 실행되면서 끊임없이 변한다. 값은 여러 종류가 있지만 각각의 값이 갖는 의미는 일반적이다. 어떤 값이 다른 의미나 양을 가지지 않는다.</p>\n<h6 id=\"도메인이란\"><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%B4%EB%9E%80\" aria-label=\"도메인이란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도메인이란</h6>\n<p>컴퓨터가 표현할 수 있는 데이터는 변경할 수 있는 한계가 있기 때문에 변수에 대입할 수 있는 값은 한정되 있다.</p>\n<p>데이터 형식은 그 변수에 대입할 수 있는 값의 유한집합이다.</p>\n<p>관계형 모델에서 데이터 형식은 도메인이라고 한다. 값은 그 집합의 요소 하나하나이고 변수는 어떤 시점에 그 집합에서 요소를 한 개 선택한 것으로 해석한다. 집합의 요소(값)에는 변화가 없지만 어떤 요소를 선택할 것인가(변수)는 시시각각 변할 것이다. 그 집합 전체를 도메인이라고 한다.</p>\n<p>도메인이 유한집합이라는 것은 튜플이 취득할 수 있는 값을 그 유한집합의 곱집합으로 나타낼 수 있다는 말이다.</p>\n<p>튜플은 제목에 정의된 속성의 곱집합 중 한개의 요소다. 릴레이션은 속성의 도메인의 곱집합에서 특정 튜플만 선택해 구성한 집합이다.</p>\n<p>관계형 모델은 릴레이션을 구성하는 제목, 본체, 튜플뿐만 아니라 속성의 데이터 형식조차도 집합으로 되어 있다.</p>\n<h4 id=\"sql에서-릴레이션-조작\"><a href=\"#sql%EC%97%90%EC%84%9C-%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98-%EC%A1%B0%EC%9E%91\" aria-label=\"sql에서 릴레이션 조작 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL에서 릴레이션 조작</h4>\n<h5 id=\"select의-기본형\"><a href=\"#select%EC%9D%98-%EA%B8%B0%EB%B3%B8%ED%98%95\" aria-label=\"select의 기본형 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SELECT의 기본형</h5>\n<p>SELECT는 SQL에서 데이터를 조회하는 데 사용하는 유일한 명령이다. <strong><em>질의</em></strong> 기능은 전부 SELECT에 들어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> 컬럼의 목록\n<span class=\"token keyword\">FROM</span> 테이블의 목록\n<span class=\"token keyword\">WHERE</span> 검색 조건</code></pre></div>\n<p>위의 세 항목은 모두 각각 릴레이션의 대수 연산에 해당 하며, 컬럼의 목록은 Projection, 테이블의 목록은 곱집합(Product), 검색 조건은 제한(Restrict)이다.</p>\n<p>연산이 평가되는 순서</p>\n<ol>\n<li>테이블의 목록(곱집합)</li>\n<li>검색 조건(제한)</li>\n<li>컬럼의 목록(프로젝션)</li>\n</ol>\n<p>밑의 쿼리를 보면서 같이 공부해보자</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> t1<span class=\"token punctuation\">.</span>c1<span class=\"token punctuation\">,</span> t1<span class=\"token punctuation\">.</span>c2<span class=\"token punctuation\">,</span> t2<span class=\"token punctuation\">.</span>c3\n<span class=\"token keyword\">From</span> t1 <span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> t2\n<span class=\"token keyword\">WHERE</span> t1<span class=\"token punctuation\">.</span>c4 <span class=\"token operator\">=</span> t2<span class=\"token punctuation\">.</span>c5 <span class=\"token operator\">AND</span> t2<span class=\"token punctuation\">.</span>c6 <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>SELECT 문에서 항목들이 평가되는 순서와 실제로 RDB에 의해 어떤 순서로 실행되는지는 관계가 없다. RDB에서는 옵티마이저가 최적화를 하여 처리를 생략하거나 실행 순서를 바꾼다.</p>\n<h5 id=\"확장의-평가-순서\"><a href=\"#%ED%99%95%EC%9E%A5%EC%9D%98-%ED%8F%89%EA%B0%80-%EC%88%9C%EC%84%9C\" aria-label=\"확장의 평가 순서 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장의 평가 순서</h5>\n<p>관계형 모델에서는 새로운 속성(SQL에서는 컬럼)을 추가하는 작업을 확장(Extend)라고 한다. 평가는 프로젝션 전에 수행된다.</p>\n<h5 id=\"insert삽입\"><a href=\"#insert%EC%82%BD%EC%9E%85\" aria-label=\"insert삽입 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>INSERT(삽입)</h5>\n<p>사실 관계형 모델에는 갱신이라는 개념이 존재하지 않는다. 릴레이션은 값이기 때문에 갱신하는 것은 불가능 하다.</p>\n<p>SQL 에서는 테이블 내의 값을 변경할 수 있다. INSERT는 행을 추가하지만, 행을 추가해 테이블의 값(릴레이션)이 바뀌는 것처럼 보인다.</p>\n<p>위의 모순은 테이블이 값과 변수라는 양쪽의 역할을 하기 때문이다. 관계형 모델에서 릴레이션을 저장하는 변수는 Relvar(Relation Variable, 관계 변수)라고 한다. 즉 SQL에서 테이블의 갱신 처리는 Relvar의 역할로 테이블에 해당된 릴레이션의 값을 변경하는것이다.</p>\n<p>INSERT는 Relvar의 값( = 릴레이션)을 해당 릴레이션에 새롭게 INSERT 할 튜플(행)을 추가하고 릴레이션과 바꾸는 작업을 한다. 관계형 모델에서 릴레이션의 연산은 입력도 출력도 릴레이션이다. <code class=\"language-text\">R:= R ∪ {T}</code></p>\n<h5 id=\"delete삭제\"><a href=\"#delete%EC%82%AD%EC%A0%9C\" aria-label=\"delete삭제 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DELETE(삭제)</h5>\n<p>DELETE는 차집합이라고 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> t <span class=\"token keyword\">WHERE</span> c1 <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위의것을 관계형 모델로 표현하면 전체 릴레이션(=Relvar에 대입되는 값)에서 WHERE 절의 조건인 c1 = 100에 해당하는 튜플의 집합(즉 전체의 릴레이션의 부분집합)이 되고 릴레이션의 차집합을 Relvar에 대입하는 것과 같다.</p>\n<p><code class=\"language-text\">R:= R - {T}</code></p>\n<h5 id=\"update갱신\"><a href=\"#update%EA%B0%B1%EC%8B%A0\" aria-label=\"update갱신 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UPDATE(갱신)</h5>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">UPDATE</span> t <span class=\"token keyword\">SET</span> c1 <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token keyword\">WHERE</span> c2 <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol>\n<li>전체 릴레이션에서 WHERE 절의 조건에 맞는 튜플로 이뤄진 릴레이션의 차집합을 구한다.</li>\n<li>1의 결과인 릴레이션(Where 절의 조건에 맞는 튜플로 구성된 릴레이션)에 수정을 가한 릴레이션과의 합집합을 구한다.</li>\n<li>2의 합집합을 Relvar에 대입한다.</li>\n</ol>\n<p><code class=\"language-text\">R:=(R-{T1})∪{T2}</code></p>\n<h4 id=\"sql에는-있고-관계형-모델에는-없는것\"><a href=\"#sql%EC%97%90%EB%8A%94-%EC%9E%88%EA%B3%A0-%EA%B4%80%EA%B3%84%ED%98%95-%EB%AA%A8%EB%8D%B8%EC%97%90%EB%8A%94-%EC%97%86%EB%8A%94%EA%B2%83\" aria-label=\"sql에는 있고 관계형 모델에는 없는것 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL에는 있고 관계형 모델에는 없는것</h4>\n<p>SQL을 효과적으로 사용하기 위한 요령은 무엇보다도 모델에 맞게 사용하는 것이다.</p>\n<h5 id=\"요소의-중복\"><a href=\"#%EC%9A%94%EC%86%8C%EC%9D%98-%EC%A4%91%EB%B3%B5\" aria-label=\"요소의 중복 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요소의 중복</h5>\n<p>릴레이션은 구조가 같은 튜플의 집합이다. 집합은 수학적 의미에서의 집합이다. 집합은 중복되지 않으므로 릴레이션도 마찬가지다.</p>\n<p>SQL은 테이블에 같은 행이 있더라도 괜찮다. 기본키와 같은 유일성 제약이 있다면 테이블에 중복되는 행이 존재하지 않지만, 그렇지 않다면 가능하다. 즉 테이블은 원래 집합이 아니다. 테이블은 다중집합(Multiset)이라고 할 수 있다.</p>\n<p>SQL 관계형 모델에 맞게 사용하려면 테이블을 집합처럼 사용해야 한다. 적어도 어딘가에 유일성 제약이 있어야한다.</p>\n<h5 id=\"요소-사이의-순서\"><a href=\"#%EC%9A%94%EC%86%8C-%EC%82%AC%EC%9D%B4%EC%9D%98-%EC%88%9C%EC%84%9C\" aria-label=\"요소 사이의 순서 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요소 사이의 순서</h5>\n<p>집합은 요소 사이의 순서가 없다. 따라서 집합으로 정의된 릴레이션(의 본체), 튜플, 제목에 포함된 요소에는 순서가 없다.</p>\n<p>하지만 SQL에는 순서가 있고, 컬럼은 정의된 순서대로 나열되고 행을 정렬할 수도 있다. 쿼리를 실행한 결과도 지정한 순서로 나열된다.</p>\n<p>관계형 모델에 따라 SQL을 사용하려면 행이나 컬럼의 위치를 고려한 쿼리를 작성해서는 안 된다. 예를 들어 ROWNUM 이나 ORDER BY 1(1번째 컬럼을 기준으로 정렬)과 같은 기능은 피해야 한다.</p>\n<h5 id=\"릴레이션의-갱신\"><a href=\"#%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98%EC%9D%98-%EA%B0%B1%EC%8B%A0\" aria-label=\"릴레이션의 갱신 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>릴레이션의 갱신</h5>\n<p>릴레이션은 값이므로 갱신할 수 없다. 값을 갱신할 수 있는 것은 변수 뿐이다. 하지만 테이블은 값과 변수의 기능을 모두 겸한다.</p>\n<h5 id=\"트랜잭션\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98\" aria-label=\"트랜잭션 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션</h5>\n<p>트랜잭션은 SQL 사양의 일부이지만 관계형 모델과는 다른 독립적인 개념으로 관계형 모델에 포함되지 않는다.</p>\n<p>관계형 모델과 트랜잭션은 다른 개념이지만 RDB를 사용하려면 양쪽을 바르게 이해하고 사용해야 한다.</p>\n<p>두 가진는 상호 보완적인 관계이며 RDB에서 두개의 축이라고 할 수 있다.</p>\n<h5 id=\"스토어드-프로시저\"><a href=\"#%EC%8A%A4%ED%86%A0%EC%96%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80\" aria-label=\"스토어드 프로시저 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스토어드 프로시저</h5>\n<p>관계형 모델에는 프로시저가 존재하지 않는다. 따라서 커서를 루프로 처리하는 작업은 관계형 모델에서는 없다. 오히려 테이블을 루프로 처리하는 것은 집합 연산을 정면으로 부정하는 행위다.</p>\n<h5 id=\"null\"><a href=\"#null\" aria-label=\"null permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NULL</h5>\n<p>집합에는 NULL이라는 개념이 없다. 단지 요소가 포함돼 있을 뿐이다. 요소는 존재하면 집합에 포함되고 그렇지 않으면 집합에 해당하는 요소는 포함되지 않는다.</p>\n<p>NULL은 값이 존재하지 않거나 알 수 없다는 의미의  특별한 기호이며 값이 아니다. 따라서 NULL을 집합에 포함할 수 없다.</p>\n<h4 id=\"요약\"><a href=\"#%EC%9A%94%EC%95%BD\" aria-label=\"요약 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h4>\n<p>SQL에서 릴레이션의 연산이 가능하다는 것은 릴레이션에 해당하는 테이블이 릴레이션과 공통된 성질을 가져야 한다는 것이다. 즉, 릴레이션과 테이블은 여러 부분에서 차이가 있지만 적어도 테이블을 릴레이션의 성질과 비슷하게 하는 것이 효과적으로 SQL을 작성하기 위한 필수 조건이다.</p>\n<p>관계형 모델은 수학(집합론)을 바탕으로 한 강력한 데이터 모델이며 쿼리(질의)의 정확도 역시 수학에 의해 보장된다. 아무리 현실에 맞게 모델을 바꾸더라도 집합이 가진 수학적인 성질은 바뀌지 않는다.</p>\n<p>중요한 것은 관계형 모델의 한계를 알고, 관계형 모델을 적용할 수 있는 부분과 그렇지 않은 부분을 파악하는 것이다.</p>\n<h3 id=\"2술어-논리와-관계형-모델\"><a href=\"#2%EC%88%A0%EC%96%B4-%EB%85%BC%EB%A6%AC%EC%99%80-%EA%B4%80%EA%B3%84%ED%98%95-%EB%AA%A8%EB%8D%B8\" aria-label=\"2술어 논리와 관계형 모델 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.술어 논리와 관계형 모델</h3>\n<h4 id=\"술어-논리와-관계형-모델\"><a href=\"#%EC%88%A0%EC%96%B4-%EB%85%BC%EB%A6%AC%EC%99%80-%EA%B4%80%EA%B3%84%ED%98%95-%EB%AA%A8%EB%8D%B8\" aria-label=\"술어 논리와 관계형 모델 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>술어 논리와 관계형 모델</h4>\n<p>관계형 모델은 집합론을 기초로 한 데이터 모델이며 술어 논리라는 소위 논리학에 기초한 데이터 모델이다.</p>\n<p>술어논리는 관계형 모델의 본질이며 논리학을 기반으로 하지 않는 정규화의 설명은 엉터리라고 해도 과언이 아니다.</p>\n<h5 id=\"명제\"><a href=\"#%EB%AA%85%EC%A0%9C\" aria-label=\"명제 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>명제</h5>\n<p>명제란 어떤 사물에 관해 설명한 문장이 그 의미가 정확한지, 즉 참인지 거짓인지 물을 수 있는 문장이다.</p>\n<h5 id=\"명제논리\"><a href=\"#%EB%AA%85%EC%A0%9C%EB%85%BC%EB%A6%AC\" aria-label=\"명제논리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>명제논리</h5>\n<p>논리학이란 명제의 관계를 연구하는 학문이며, 어떤 명제(한개 또는 여러개)의 참과 거짓을 알고 있을 때 다른 명제의 참과 거짓이 무엇인지 알아내는 데 특화된 학문.</p>\n<p>명제의 참과 거짓을 이용해 다른 명제의 참과 거짓을 증명할때 중요한 것은 참과 거짓 값 뿐이며 명제가 가진 다른 의미는 아무 영향을 끼치지 않는다.</p>\n<p>명제에서 참과 거짓 이외의 의미를 제거하기 위해 명제를 P나 Q등의 기호로 표현한다.</p>\n<h5 id=\"논리연결자\"><a href=\"#%EB%85%BC%EB%A6%AC%EC%97%B0%EA%B2%B0%EC%9E%90\" aria-label=\"논리연결자 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(논리)연결자</h5>\n<p>두 가지 또는 한 개의 명제에서 새로운 참과 거짓을 도출하기 위한 기호를 연결자라고 한다.</p>\n<ol>\n<li>NOT</li>\n<li>AND</li>\n<li>OR</li>\n<li>IMP</li>\n<li>EQ</li>\n<li>NAND</li>\n<li>NOR</li>\n<li>XOR</li>\n</ol>\n<h5 id=\"진리함수의-진리값\"><a href=\"#%EC%A7%84%EB%A6%AC%ED%95%A8%EC%88%98%EC%9D%98-%EC%A7%84%EB%A6%AC%EA%B0%92\" aria-label=\"진리함수의 진리값 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>진리함수의 진리값</h5>\n<p>연결자는 일반적으로 논리연산이라고 불리며 논리기호는 두 가지 또는 한 가지의 진리값을 가지며 식 전체의 진리값을 고유하게 결정하는 역할을 한다. 이런 성질을 가지는 것을 진리함수라고 한다.</p>\n<h5 id=\"동어-반복과-정리\"><a href=\"#%EB%8F%99%EC%96%B4-%EB%B0%98%EB%B3%B5%EA%B3%BC-%EC%A0%95%EB%A6%AC\" aria-label=\"동어 반복과 정리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동어 반복과 정리</h5>\n<h6 id=\"동어-반복tautology\"><a href=\"#%EB%8F%99%EC%96%B4-%EB%B0%98%EB%B3%B5tautology\" aria-label=\"동어 반복tautology permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동어 반복(Tautology)</h6>\n<p><code class=\"language-text\">(P ⊃ Q) ⊃ ¬(¬Q ⊃ ¬P)</code>\n위의 진리표는 매개변수가 되는 명제의 값에 상관없이 결과가 항상 참이 되는 논리식을 동어반복 또는 항진식이라고 한다.</p>\n<p>명제논리에서 동어반복은 언제 어떠한 상황에서도 성립하는 절대적인 법칙, 즉 진리와 같은 것이라고 할 수 있다.</p>\n<p>동어반복은 어떤 설명이 바른지 아닌지 증명하는 데 사용하거나 참이 되는 논리식에서 다른 참이 되는 논리식을 도출할 때 사용한다.</p>\n<p>명제논리에서 동어반복은 정의돼 있는 것이다.</p>\n<h5 id=\"정리\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h5>\n<p>다음은 명제논리에서 자주 사용되는 정리, 즉 동어반복이다.</p>\n<p><code class=\"language-text\">동일법칙... P ⊃ P</code></p>\n<p><code class=\"language-text\">배중법칙... P ⊃ P</code></p>\n<p><code class=\"language-text\">이중부정법칙... P ⊃ P</code></p>\n<p><code class=\"language-text\">모순법칙... P ⊃ P</code></p>\n<p><code class=\"language-text\">Principle of explosion 법칙... P ⊃ P</code></p>\n<p><code class=\"language-text\">대우법칙... P ⊃ P</code></p>\n<p><code class=\"language-text\">추이법칙... P ⊃ P</code></p>\n<p><code class=\"language-text\">분배법칙... P ⊃ P</code></p>\n<p><code class=\"language-text\">드 모르간법칙... P ⊃ P</code></p>\n<p><code class=\"language-text\">전건긍정식... P ⊃ P</code></p>\n<p><code class=\"language-text\">후건부정식... P ⊃ P</code></p>\n<p><code class=\"language-text\">선언적삼단논법... P ⊃ P</code></p>\n<h5 id=\"명제논리와-공리계\"><a href=\"#%EB%AA%85%EC%A0%9C%EB%85%BC%EB%A6%AC%EC%99%80-%EA%B3%B5%EB%A6%AC%EA%B3%84\" aria-label=\"명제논리와 공리계 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>명제논리와 공리계</h5>\n<p>각 정리에는 그 정리가 올바른지, 즉 참인 것을 보장하기 위한 전제가 되는 정리가 있어야 한다.</p>\n<h6 id=\"공리\"><a href=\"#%EA%B3%B5%EB%A6%AC\" aria-label=\"공리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공리</h6>\n<p>정리는 아무런 전제 없이도 올바르다고 인정하자는 합의하에 정해진 다른 정리의 출발점이 되는 것이다. 이를 공리라고 하며 모든 정리는 공리가 출발점이다. 바꾸어 말하면 정리란 공리에서 도출된 논리적으로 올바른 명제다. 정리의 정확성은 공리에 의해서 보장되고 있는 것이다.</p>\n<p>공리는 다양한 정리에 전제로 사용되므로 마음대로 공리를 만들수 없다.</p>\n<p>공리는 하나뿐 아니라 여러 개의 명제를 조합하여 성립한다. 공리로 정의된 명제끼리 모순이 없어야 하고 공리는 다뤄지는 주제가 전체를 포괄할 수 있는 것을 가정하여 정의해야 한다. 이처럼 고민하고 정한 공리의 집합을 공리계라고 한다.</p>\n<h6 id=\"공리계의-예제\"><a href=\"#%EA%B3%B5%EB%A6%AC%EA%B3%84%EC%9D%98-%EC%98%88%EC%A0%9C\" aria-label=\"공리계의 예제 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공리계의 예제</h6>\n<p>하나의 주제를 다루는 공리계는 절대적으로 유일하다고 할 수 없다? 무모순성이나 완전성을 만족시키는 공리계는 몇 가지의 변종이 있을 때도 있다?</p>\n<p>명제 논리의 공리계 중 대표적인 것이 사실은 공리가 아닌(공집합) 버전이 있다. 공리는 정의돼있지 않지만, 네개의 연결자(⊃, ¬, ∧, ∨) 각각에 대해 도립과 제거를 위한 다음과 같은 여덜개의 규칙을 정의해 공리계가 성립된다.</p>\n<ol>\n<li>⊃ 도입</li>\n<li>⊃ 제거</li>\n<li>¬ 도입</li>\n<li>¬ 제거</li>\n<li>∨ 도입</li>\n<li>∨ 제거</li>\n<li>∧ 도입</li>\n<li>∧ 제거</li>\n</ol>\n<h5 id=\"명제논리의-한계와-양화논리양한정\"><a href=\"#%EB%AA%85%EC%A0%9C%EB%85%BC%EB%A6%AC%EC%9D%98-%ED%95%9C%EA%B3%84%EC%99%80-%EC%96%91%ED%99%94%EB%85%BC%EB%A6%AC%EC%96%91%ED%95%9C%EC%A0%95\" aria-label=\"명제논리의 한계와 양화논리양한정 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>명제논리의 한계와 양화논리(양한정)</h5>\n<h6 id=\"명제-논리의-한계\"><a href=\"#%EB%AA%85%EC%A0%9C-%EB%85%BC%EB%A6%AC%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"명제 논리의 한계 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>명제 논리의 한계</h6>\n<p>명제논리는 단적으로 말하면 명제 사이의 관계성에 관해서 여러 가지 생각을 할 수 있는 학문이다. 어떤 사실을 단순히 참과 거짓 값을 가진 명제로 표현할 수 없다면 문제 없지만 그렇지 않은 경우, 즉 사실을 단순한 명제를 이용해 표현할 수 없을 때는 대응할 수 없다.</p>\n<h6 id=\"양화논리\"><a href=\"#%EC%96%91%ED%99%94%EB%85%BC%EB%A6%AC\" aria-label=\"양화논리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>양화논리</h6>\n<p>위의 문제를 해결할 것이 양화논리다. 양화논리란 쉽게 말해서 집단을 대상으로 참과 거짓을 묻는 것이다. 술어논리에서 다루는 양화논리는 기본적으로 다음과 같이 두 종류가 있다.</p>\n<ol>\n<li>범용정량 : 어떤 집단의 요소 전체가 어떠한 성질을 충족하는가 ?</li>\n<li>존재정량 : 어떤 집단에 어떠한 성질을 충족하는 요소가 존재하는가 ?</li>\n</ol>\n<h5 id=\"정량자와-술어논리\"><a href=\"#%EC%A0%95%EB%9F%89%EC%9E%90%EC%99%80-%EC%88%A0%EC%96%B4%EB%85%BC%EB%A6%AC\" aria-label=\"정량자와 술어논리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정량자와 술어논리</h5>\n<ol>\n<li>\n<p>어떤 집단의 요소 전체가 어떤 성질을 충족한다는 것은 범용정량자(∀)를 사용해 표현한다.</p>\n<ul>\n<li>이 마을의 주민 모두는 정직하다.</li>\n<li>x는 정직하다를 함수 F(x)라고 하자.</li>\n<li>∀xF(x)로 표현할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>어떤 집단에 어떠한 성질을 충족하는 요소가 존재하는가 ?</p>\n<ul>\n<li>이 마을엔 정직하지 않은 사람이 있다.</li>\n<li>x는 정직하다를 함수 F(x)라고 하면 정직하지 않다는 ¬F(x)로 표현할 수 있다.</li>\n<li>∃x¬F(x)로 표현할 수 있다.</li>\n</ul>\n</li>\n</ol>\n<h6 id=\"술어-논리\"><a href=\"#%EC%88%A0%EC%96%B4-%EB%85%BC%EB%A6%AC\" aria-label=\"술어 논리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>술어 논리</h6>\n<p>변수와 정량자 그리고 함수를 사용해 집단에 대한 성질을 기술한 문장을 논리식으로 표현할 수 있다. 이러한 표현을 사용한 명제논리를 확장한 체계를 술어논리라고 한다.</p>\n<h5 id=\"정량자와-함께-사용하는-속박변수\"><a href=\"#%EC%A0%95%EB%9F%89%EC%9E%90%EC%99%80-%ED%95%A8%EA%BB%98-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%86%8D%EB%B0%95%EB%B3%80%EC%88%98\" aria-label=\"정량자와 함께 사용하는 속박변수 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정량자와 함께 사용하는 속박변수</h5>\n<p>정량자 ∀나 ∃와 함께 사용되는 변수는 속박변수라고 한다. 변수의 범위가 정량자의 영향 범위에 속박돼있어서 속박변수라고 한다.\n<code class=\"language-text\">∃ x F(x) ∧ ∀ x G(x)</code> 를 예를 들면 공통 기호 변수 x를 사용하고 있지만, ∧를 기준으로 다른 변수를 의미한다.</p>\n<h6 id=\"정량자를-사용하지-않는-자유변수\"><a href=\"#%EC%A0%95%EB%9F%89%EC%9E%90%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%9E%90%EC%9C%A0%EB%B3%80%EC%88%98\" aria-label=\"정량자를 사용하지 않는 자유변수 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정량자를 사용하지 않는 자유변수</h6>\n<p>정량자를 사용하지 않는 변수를 자유변수라고 한다.\n<code class=\"language-text\">F(X) ⊃ G(x)</code>는 논리식에서 첫 번째 x도 두 번째 x도 같은 x를 가리킨다.\nx에는 임의의 값이 들어갈 가능성이 있으므로 x의 값에 따라 F(x)의 값도 바뀐다. 그리고 F(x)를 평가한 결과 값은 참 또는 거짓이다. 자유변수를 인자로 받아서 참과 겆시을 반환하는 함수를 명제함수라고 하며, 명제함수는 <strong><em>술어</em></strong>라고도 한다. 술어라고 하는 이유는 주어가 되는 것이 변수 x이며 함수 자체는 x에 대한 성질을 나타내기 때문이다. <strong><em>술어논리는 술어를 이용한 논리체계이다</em></strong></p>\n<h5 id=\"술어논리와-집합론\"><a href=\"#%EC%88%A0%EC%96%B4%EB%85%BC%EB%A6%AC%EC%99%80-%EC%A7%91%ED%95%A9%EB%A1%A0\" aria-label=\"술어논리와 집합론 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>술어논리와 집합론</h5>\n<h6 id=\"술어와-집합은-등가교환-가능\"><a href=\"#%EC%88%A0%EC%96%B4%EC%99%80-%EC%A7%91%ED%95%A9%EC%9D%80-%EB%93%B1%EA%B0%80%EA%B5%90%ED%99%98-%EA%B0%80%EB%8A%A5\" aria-label=\"술어와 집합은 등가교환 가능 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>술어와 집합은 등가교환 가능</h6>\n<p>양화라는 생각은 임의의 집단을 가정해 그 집단의 요소 전원이 어떤 성질을 만족하거나 성질을 만족하는 요소가 있는지 표현하는 것이다.</p>\n<p>“코끼리는 초식동물이다” 라는 문장을 생각해보자.\n<code class=\"language-text\">∀x(F(x)⊃G(x))</code> 이 식은 “x가 코끼리다”라는 술어를 F(x), “x는 초식이다”라는 술어를 G(x)라고 했다. F(x)라는 술어는 x가 코끼리이면 참 그렇지 않으면 거짓을 반환하는 함수다.</p>\n<p>F(x)는 “x가 코끼리다”를 나타내는 술어이므로 F(x)가 참이 되는 모든 x는 모든 코끼리를 포함한 집합이라고 의역할 수 있다. 즉 F(x)라는 술어는 <code class=\"language-text\">x ∈ SF</code>라는 집합과 요소의 포함관계로 바꾸어 표현할 수 있다. 여기서 SF는 F(x)가 참이 되는 x의 집합을 표현한다.\n앞의 논리식을 집합으로 <code class=\"language-text\">∀x(x∈SF ⊃ x∈SG)</code>로 표현할 수 있다. 술어 F(x)와 G(x)를 사용해 표현한 조금 전의 논리식도, 집합 SF, SG를 사용해 표현한 논리식도 식이 의미하는 참과 거짓은 같다. 술어와 집합은 등가교환을 할 수 있다.</p>\n<h6 id=\"집합의-포함관계\"><a href=\"#%EC%A7%91%ED%95%A9%EC%9D%98-%ED%8F%AC%ED%95%A8%EA%B4%80%EA%B3%84\" aria-label=\"집합의 포함관계 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>집합의 포함관계</h6>\n<p>⊃는 왼쪽 논리식의 조건이 참이면 오른쪽의 논리식도 참이 된다는 의미다. ⊆는 집합의 포함관계를 나타낸다.\n왼족의 논리식이 거짓이라면 오른쪽의 논리식은 거짓이든 상관 업다. 이 경우 <code class=\"language-text\">x ∈ SF</code>는 거짓이고 <code class=\"language-text\">x ∈ SG</code>가 참일 수도 있다. 개별 요소에 대해서 보면 SF는 포함되있지 않더라도 SG에는 포함된 x가 있다는 것이다. 이를 포함관계로 나타내면 <code class=\"language-text\">SF ⊆ SG</code>이다.</p>\n<p><code class=\"language-text\">F(x)⊃G(x)</code> 는 “x가 코리리라면 x는 초식이다” 라는 의미의 술어다. <code class=\"language-text\">SF ⊆ SG</code>는 “코끼리라는 집합은 초식동물일나느 집합에 포함된다”는 의미로 양쪽 모두 의미로서는 맞다는걸 알 수 있다.</p>\n<h6 id=\"집합과-요소의-포함-관계-차이\"><a href=\"#%EC%A7%91%ED%95%A9%EA%B3%BC-%EC%9A%94%EC%86%8C%EC%9D%98-%ED%8F%AC%ED%95%A8-%EA%B4%80%EA%B3%84-%EC%B0%A8%EC%9D%B4\" aria-label=\"집합과 요소의 포함 관계 차이 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>집합과 요소의 포함 관계 차이</h6>\n<p>집합이 원소를 포함하는 의미의 기호는 ∈다. ⊆는 ∈와 달리 집합 사이의 포함관계를 나타낸다. <code class=\"language-text\">S1 ⊆ S2</code>는 S1이 S2의 부분집합(subset)임을 나타낸다.</p>\n<h6 id=\"술어논리의-공리계\"><a href=\"#%EC%88%A0%EC%96%B4%EB%85%BC%EB%A6%AC%EC%9D%98-%EA%B3%B5%EB%A6%AC%EA%B3%84\" aria-label=\"술어논리의 공리계 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>술어논리의 공리계</h6>\n<p><code class=\"language-text\">∀ x F(x)</code>는 ∀ x {x ∈ SF}로 표현할 수 있다. SF를 n개의 요소를 가진 집합이라 하면 {a1, a2, a3, a4, …}로 표현할 수 있다. 이는 <code class=\"language-text\">F(a1) ∧ F(a2) ∧ F(a3)... ∧ F(an)</code>로 표현할 수 있으며 <code class=\"language-text\">∃ x F(x)</code>를 <code class=\"language-text\">F(a1) ∨ F(a2) ∨ F(a3)... ∨ F(an)</code> 와같이 표현할 수 있다.</p>\n<p>∀ 와 ∃는 ∧ 와 ∨를 사용해 표현할 수 있다. 예를 들어 드 모르간의 법칙은 정량자에도 성립된다.\n<code class=\"language-text\">¬∃xF(x) ≡ ∀x¬F(x) , ¬∀xF(x) ≡ ∃x¬F(x)</code></p>\n<h6 id=\"술어논리의-공리계-도출-규칙\"><a href=\"#%EC%88%A0%EC%96%B4%EB%85%BC%EB%A6%AC%EC%9D%98-%EA%B3%B5%EB%A6%AC%EA%B3%84-%EB%8F%84%EC%B6%9C-%EA%B7%9C%EC%B9%99\" aria-label=\"술어논리의 공리계 도출 규칙 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>술어논리의 공리계 도출 규칙</h6>\n<h5 id=\"도메인\"><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8\" aria-label=\"도메인 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도메인</h5>\n<p>술어논리는 논의의 대상이 되는 집합을 가정하는 것이 일반적이며, 이처럼 논의의 대상이 되는 집합을 도메인, 영어로는 Domain of discourse 또는 단순하게 영역이라고 부른다. 이 개념은 관계형 모델에서도 통용된다.</p>\n<h5 id=\"릴레이션의-참의-형태\"><a href=\"#%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98%EC%9D%98-%EC%B0%B8%EC%9D%98-%ED%98%95%ED%83%9C\" aria-label=\"릴레이션의 참의 형태 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>릴레이션의 참의 형태</h5>\n<p>집합이 1차 술어논리와 1 : 1로 대응되는 것에 관해 설명했다. 이 사실에서 유추되는 결론은 릴레이션에는 대응하는 술어가 있다는 것이다.\n|name|age of death|\n|----|------------|\n|태조|74|\n|정종|63|\n|태종|56|\n|세종|54|\n|문종|30|\n|…| …|</p>\n<p>위의 릴레이션의 술어는 “x라는 인물은 조선 초기 왕이었고, 그 사람은 y살에 사망했다”가 될 수 있다. 술어를 F(x, y)로 표시할 수 있고, 릴레이션의 요소는 튜플이므로 술어에 대입하면 튜플이된다. 따라서 튜플을 하나의 단위로 F(t)로 표현할 수 있다.</p>\n<p><strong><em>가장 중요한 점은 이 릴레이션에 포함된 튜플은 모두 F(t)에 대입하면 참으로 평가된다</em></strong>.</p>\n<h6 id=\"릴레이션의-연산은-논리연산\"><a href=\"#%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98%EC%9D%98-%EC%97%B0%EC%82%B0%EC%9D%80-%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0\" aria-label=\"릴레이션의 연산은 논리연산 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>릴레이션의 연산은 논리연산</h6>\n<p>릴레이션이 참인 명제의 집합이라는 것은 릴레이션의 연산은 논리연산 외에는 없다는 말이다. 즉 DB에 대한 질의를 수행하는 것은 어떤 데이터가 필요한지를 술어로 표현하고 그 술어에 대한 논리연산을 수행한 결과, 쿼리에 해당하는 술어가 참이 되는 집합을 새롭게 취득하는 동작이다. 쿼리(DB에 질의)를 작성하는 행위는 술어를 표현하는 것 외에는 없다.</p>\n<h5 id=\"폐쇄-세계-가정\"><a href=\"#%ED%8F%90%EC%87%84-%EC%84%B8%EA%B3%84-%EA%B0%80%EC%A0%95\" aria-label=\"폐쇄 세계 가정 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>폐쇄 세계 가정</h5>\n<p>관계형 모델은 술어에 대입해 참이 되는 것은 릴레이션에 포함되는 튜플뿐이며 참이 되는 명제는 모두 빠짐없이 릴레이션에 포함되는 것으로 가정하고 있다. 이 가정을 폐쇄 세계 가정(Closed World Assumption)이라고 한다. 즉 알지 못하는 사실은 존재하지 않고 ‘사실’은 모두 판명돼 있다고 생각하고 이를 전제로 데이터 모델을 설계하자는 생각이다.</p>\n<p>폐쇄 세계 가정이 가설이라면 릴레이션은 ‘사실’인 모두를 정확하고 빠짐없이 포함하고 있으며 릴레이션의 연산 결과에서 얻는 새로운 릴레이션도 ‘사실’이 정확하게 모두 포함돼 있게 된다. 그러면 모든 질의를 릴레이션의 연산만으로 해결할 수 있다.</p>\n<h5 id=\"모순된-db는-쓸모없다\"><a href=\"#%EB%AA%A8%EC%88%9C%EB%90%9C-db%EB%8A%94-%EC%93%B8%EB%AA%A8%EC%97%86%EB%8B%A4\" aria-label=\"모순된 db는 쓸모없다 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모순된 DB는 쓸모없다</h5>\n<p>관계형 모델은 술어논리의 규칙에 좌우되는 데이터 모델이며 술어논리에서 복잡한 것은 관계형 모델에서도 일어날 수 있다.</p>\n<p>술어논리에 있어 가장 복잡한 것은 모순이다. 전제에 모순이 포함돼 있으면 Principle of explosion 정리에 따라 어떠한 결과도 도출할 수 있게 된다. 즉 모순된 데이터를 가진 릴레이션에서 도출된 질의의 결과는 전혀 믿을 수 없게 된다.</p>\n<h2 id=\"노트\"><a href=\"#%EB%85%B8%ED%8A%B8\" aria-label=\"노트 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노트</h2>\n<h3 id=\"관계형-모델-1\"><a href=\"#%EA%B4%80%EA%B3%84%ED%98%95-%EB%AA%A8%EB%8D%B8-1\" aria-label=\"관계형 모델 1 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>관계형 모델</h3>\n<p>관계형 모델은 릴레이션 단위로 다양한 연산을 사용해 질의를 수행하는 데이터 모델이다. 릴레이션의 단위로 릴레이션끼리 연산해서 릴레이션을 얻기위해 만들어 놓는 것이 관계형 모델이다. </p>\n<p>왜 릴레이션이라고 했을까 ? 집합은 셋을 쓰는데 테이블은 셋이 아님 속성의 튜플 집합. 튜플들에 릴레이션이 있다라는 말이다.헤딩에 있는 어트리뷰트가 그 튜플에는 똑같이 나온다는 횡적 관심사가 일치하는 애들이 나와 라고 볼 수 있음.</p>\n<p>릴레이션에 중요한것. 바디와 헤더가 따로 관리된다. </p>\n<p>어트리뷰트에는 순서가 없어야 한다. 제1정규화 규칙임. 그래서 순서로 가져오는것을 절대 하면 안된다.</p>\n<p>튜플은 개념적인거고, 구현적인 것에선 레코드란 것으로 사용.</p>\n<h3 id=\"집합\"><a href=\"#%EC%A7%91%ED%95%A9\" aria-label=\"집합 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>집합</h3>\n<p>집합의 요소는 더 분해될 수 없다 -> 요소는 값이다. 값은 분해되지 않는것이다. 집합의 요소는 모두 값이다. 하지만 튜플은 객체같은 놈임. 그러면 튜플의 대표값을 테이블에 </p>\n<p>제한</p>\n<p>부분 집합이라서 원래 릴레이션을 갖고 있어서 얘는 sql의 where에 들어감. A 테이블이 헤더가 일치하기 때문이다. 단축 표현인 것임. 릴레이션이 </p>\n<p>셀렉트에 들어가는건 헤딩을 바꾸는 것임. 제한이 훼어에 들어가는건 헤딩을 바꾸지 않기 때문이다. 프로젝션과 확장이 헤딩을 특별한 애임. 헤딩을 건들기 때문이다.</p>\n<p>합집합</p>\n<p>헤딩이 일치한 릴레이션끼리만 union, Intersect, different 가 가능하다.\n우리는 다 릴레이션 단위의 연산을 하고 있다. 지금 까지 . 튜플안의 것이 아니라 , 튜플에 대한 연산을 하고 있음.</p>\n<p>곱집합은 컴비내이션으로 이야기할 수 있음.\n속성에 순서가 없기 때문에 위와 같이 되는 것임.</p>\n<h3 id=\"교집합과-곱집합은-결합의-특수한-예다\"><a href=\"#%EA%B5%90%EC%A7%91%ED%95%A9%EA%B3%BC-%EA%B3%B1%EC%A7%91%ED%95%A9%EC%9D%80-%EA%B2%B0%ED%95%A9%EC%9D%98-%ED%8A%B9%EC%88%98%ED%95%9C-%EC%98%88%EB%8B%A4\" aria-label=\"교집합과 곱집합은 결합의 특수한 예다 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교집합과 곱집합은 결합의 특수한 예다</h3>\n<p>결합은 서로 헤딩이 달라도 할 수 있지만 교집합은 같아야만 가능 한것이다.</p>\n<p>join은 attribute를 결합하는 것이다.</p>\n<h2 id=\"5fs\"><a href=\"#5fs\" aria-label=\"5fs permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5Fs</h2>\n<h3 id=\"1-fact\"><a href=\"#1-fact\" aria-label=\"1 fact permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Fact</h3>\n<ul>\n<li>DB 스터디를 진행 했다.</li>\n<li>논리학 부분에서 추론규칙 8가지를 모두 공부했다.</li>\n</ul>\n<h3 id=\"2feelings\"><a href=\"#2feelings\" aria-label=\"2feelings permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.Feelings</h3>\n<ul>\n<li>오늘 맹기완 대표님과 DB 스터디를 하는데 책을 3번이나 읽고왔는데도 불구하고 아직 모자르다.. 정말 자세하게 읽을 필요가 있는것 같다. 추론을 사용해보자.</li>\n<li>맹기완 대표님이 공부해오시는것 처럼 공부하는건 쉽지 않은것 같다. 다른 고수님들도 잘 모르시는 부분들도 많은것 같았다.</li>\n</ul>\n<h3 id=\"3findings\"><a href=\"#3findings\" aria-label=\"3findings permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.Findings</h3>\n<ul>\n<li>논리기호 ⊃ 는 가정을 나타내며 “이면” 으로 해석된다. 계속 집합의 것과 헷갈렸다.</li>\n<li>관계형 모델에서는 릴레이션과 릴레이션의 연산으로 결과는 릴레이션이 나오고 이런 특징을 클로저라고 한다.</li>\n<li>도메인은 표현할 수 있는 형식의 집합 범위이다.</li>\n<li>릴레이션에 추가 수정 삭제를 할 경우 union을 기반으로 연산을 한 새로운 릴레이션을 만들어 내는것이다.</li>\n</ul>\n<h3 id=\"4future-action-plan\"><a href=\"#4future-action-plan\" aria-label=\"4future action plan permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.Future Action Plan</h3>\n<ul>\n<li>내일 DB 책 1장 한번 더 읽는다.</li>\n<li>추론규칙 1,2,3,4 장을 복습한다.</li>\n<li>졸프와 OOSE 수업 프로젝트의 requirements를 세운다.</li>\n<li>책사오고 필요한 책 가져온다.</li>\n</ul>\n<h3 id=\"5feedback\"><a href=\"#5feedback\" aria-label=\"5feedback permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.FeedBack</h3>","frontmatter":{"title":"2020-04-01 TIL","date":"April 01, 2020"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/til/2020-04-01/","previous":{"fields":{"slug":"/til/2020-03-31/"},"frontmatter":{"title":"2020-03-31 TIL","category":"TIL"}},"next":{"fields":{"slug":"/study/booklist/"},"frontmatter":{"title":"Book List","category":"BookList"}}}}