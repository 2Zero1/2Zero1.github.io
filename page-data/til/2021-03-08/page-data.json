{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/2021-03-08/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"e0c6bd51-8db1-50af-ba08-242ecfac4196","excerpt":"fact 코드숨 6장 처음부터 tdd 사이클로 진행하기 오늘은 계획을 잘 수행하지 못했다. feelings 6장을 tdd 사이클로 처음부터 시작해서 모두 하긴 했지만, 시간상 좀 더 테스트 코드를 고치거나 코드를 정리하고 린트 에러를 잡지는 못해서 아쉽다.…","html":"<ol>\n<li>\n<p>fact</p>\n<ul>\n<li>코드숨 6장 처음부터 tdd 사이클로 진행하기</li>\n<li>오늘은 계획을 잘 수행하지 못했다.</li>\n</ul>\n</li>\n<li>\n<p>feelings</p>\n<ul>\n<li>6장을 tdd 사이클로 처음부터 시작해서 모두 하긴 했지만, 시간상 좀 더 테스트 코드를 고치거나 코드를 정리하고 린트 에러를 잡지는 못해서 아쉽다.</li>\n<li>6장까지 배웠던 것을 처음부터 해보는데 내가 아직 잘 하지 못하는 부분이 많다는 것을 깨닳았다. 생각해보면 어렵지 않았던 것들이 아주 사소하고 익숙하지 못한것들로 인해 많은 시간이 소요되었다. 못하니까 공부하는 거지만 그래도 다음에 할때 더 잘하기 위해선 어떻게 해야될지 생각해 보아야겠다.</li>\n<li>오늘 계획했던 일들을 수월하게 처리하지 못했다. 하지만 그래도 잘했다. 다음번에 더 잘해야지.</li>\n</ul>\n</li>\n<li>\n<p>finding</p>\n<ul>\n<li>\n<p>코드숨 6장</p>\n<ul>\n<li>useParam을 사용하여 url 로 들어온 인자값을 가져올 수 있다. route 쪽에서 to를 url/:key로 잡으면 key값으로 오는 값을 확인할 수 있다.</li>\n<li>useHistory를 사용하여 브라우저의 history를 관리할 수 있다.</li>\n<li>history.push(url)</li>\n<li>클릭시 나오는 event를 사용하여 preventDefaut() 함수를 한다면, 태그에 연결된 액션을 하지 않도록 막을 수 있다.</li>\n</ul>\n</li>\n<li>DOM을 깨우치다 (80p~100p)</li>\n<li>clientWidth와 clientHeight 속성은 테두리 크기를 제외하고 element의 내용과 패딩을 더해서 element의 전체 크기를 반환한다.</li>\n<li>elementFromPoint()를 사용하면 HTML 문서의 특정 지점에서 최상단 element에 대한 참조를 얻을 수 있다.</li>\n<li>\n<p>scrollHeight와 scrollWidth 속성은 스크롤될 노드의 높이와 너비를 제공해준다.</p>\n<ul>\n<li>스크롤 가능한 영역 내에 있는 노드가 스크롤 가능한 영역의 뷰포트보다 작은 경우에 해당 노드의 높이와 너비를 알아야 한다면, scrollHeight와 scrollWidth는 뷰포트의 크기를 반환하므로 사용하지 않는 것이 좋다. 스크롤될 노드가 스크롤 영역보다 작은 경우, 스크롤 가능한 영역 내에 포함된 노드의 크기를 판별하려면 clientHeight와 clientWidth를 사용한다.</li>\n</ul>\n</li>\n<li>\n<p>scrollTop과 scrollLeft 속성은 스크롤 때문에 현재 뷰포트에서 보이지 않는 left나 top 까지의 픽셀을 반환한다.</p>\n<ul>\n<li>div.scrollTop(10)과 같이 프로그래밍적인 방법으로 스크롤 시킬 수 있다.</li>\n<li>10은 스크롤 된 픽셀의 값이며, top까지의 10픽셀이 뷰포트에서 보이지 않다는다는 말이다.</li>\n<li>left나 top까지 뷰포트에서 보이지 않는 내용을 픽셀로 측정한 것이다.</li>\n</ul>\n</li>\n<li>\n<p>스크롤이 가능한 노드 내에 있는 노드를 선택하면, scrollIntoView() 메서드를 사용하여 선택된 노드가 view로 스크롤되도록 할 수 있다.</p>\n<ul>\n<li>div.scrollIntoView(true)</li>\n<li>scrollIntoView() 메서드에 매개변수 true를 전달하면 해당 메서드로 하여금 스크롤된 대상 element의 top으로 스크롤 하라는 것이다.</li>\n<li>element의 bottom으로 스크롤 시키고 싶다면, scrollIntoView() 메서드에 false 매개변수를 전달한다.</li>\n</ul>\n</li>\n<li>\n<p>6장 element 노드 인라인 스타일</p>\n<ul>\n<li>style attribute(element 인라인 css 속성이라고도 함)</li>\n</ul>\n</li>\n<li>모든 HTML element는 해당 element에 한정된 인라인 CSS 속성을 넣는 데 사용할 수 있는 style attribute를 가진다.</li>\n<li>style 속성이 문자열이 아닌 CSSStyleDeclaration 개체를 반환한다는 점에 유의한다. 또 CSSStyleDeclaration 개체에는 element의 인라인 스타일만이 포함된다.(즉 스타일시트에서 단계적으로 내려오면서 게산된 스타일이 아니다)</li>\n<li>\n<p>인라인 CSS 스타일은 element 노드 개체에 존재하는 style 개체의 속성으로 각자 표현된다. 단순히 개체의 속성 값을 설정하는 것으로 element의 개발 CSS 속성을 가져오거나, 제거하는 인터페이스가 제공되는 것이다.</p>\n<ul>\n<li>div.style.backgroundColor = ‘red’;</li>\n<li>div.style.width = ‘100px’;</li>\n<li>style 개체에 포함된 속성 명에는 CSS 속성명에서 사용되는 일반적인 하이픈이 포함되지 않는다.</li>\n<li>하이픈을 제거하고 카멜 케이스로 사용하면 된다.</li>\n<li>측정 단위가 필요한 CSS의 속성인 경우 적절한 단위를 넣어줘야한다. 예 px</li>\n</ul>\n</li>\n<li>\n<p>style 개체는 CSSStyleDeclaration 개체로 element 노드의 개별 CSS 속성을 조작하는데 사용되는 setPropertyValue(propertyName, value), getPropertyValue(propertyName)메서드에 대한 접근도 제공한다.</p>\n<ul>\n<li>위의 두 메서드에 전달되는 속성명은 하이픈이 포함된 속성명을 사용한다. 카멜케이스가 아니라(background-color)</li>\n</ul>\n</li>\n<li>\n<p>CSSStyleDeclaration 개체의 cssText 속성과 getAttribute() 및 setAttribute() 메서드를 사용하면, js 문자열을 사용하여 style attribute의 전체 값을 가져오고, 설정 및 제거할 수 있다.</p>\n<ul>\n<li>cssText = ‘background-color:red;border:1px solid black;height:100px’;</li>\n<li>div.setAttribute(‘style’, ‘background-color:red;border:!px solid black;‘)</li>\n<li>style attribute 값을 새로운 문자열로 바꾸는것은 style에 여러 변경을 수행하는 가장 빠른 방법이다.</li>\n</ul>\n</li>\n<li>\n<p>element의 계층화된 CSS(즉 인라인 스타일시트, 외부 스타일시트, 브라우저 스타일시트가 계층화된 것)를 가져오려면, getComputedStyle()를 사용한다. 이 메서드는 style과 유사한 읽기 전용(값을 설정할 수 없다.)의 CSSStyleDeclaratino 개체를 제공한다.</p>\n<ul>\n<li>getComputedStyles() 메서드는 색상 값을 원래 지정된 방식에 상관없이 rgb(#, #, #) 형식으로 반환한다.</li>\n<li>단축 속성을 사용하면 안됨 margin은 안되며, marginTop을 사용해야함.</li>\n</ul>\n</li>\n<li>\n<p>인라인 스타일시트나 외부 스타일시트에 정의된 스타일 규칙은 class 및 id attribute를 사용하여 element에 추가하거나 제거할 수 있는데, element 스타일을 조작할 때 가장 일반적인 패턴이다.</p>\n<ul>\n<li>div.setAttribute(‘id’, ‘bar’); 아이디 입력</li>\n<li>div.classList.add(‘foo’); 클래스 입력</li>\n</ul>\n</li>\n<li>7장 Text 노드</li>\n<li>\n<p>HTML 문서에서 텍스트는 text 노드를 만들어내는 Text() 생성자 함수의 인스턴스로 표현된다. HTML 문서가 해석될 때, HTML 페이지의 사이에 섞여 있는 텍스트는 text 노드로 변환된다.</p>\n<ul>\n<li>Text() 생성자 함수가 text 노드를 생성한다는 결론을 내려 주지만, Text가 CharacterData, Node, Object로 부터 상속받는다는 점을 명심해야 한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Future Action Plan</p>\n<ul>\n<li>내일도 계획을 더 세부적으로 명세한 후에 todo에 작성한 후 수행하자 !</li>\n<li>내일도 기분 좋게 공부하자</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"2021-03-08 TIL","date":"March 08, 2021"}}},"pageContext":{"slug":"/til/2021-03-08/","previous":{"fields":{"slug":"/til/2021-03-05/"},"frontmatter":{"title":"2021-03-05 TIL","category":"TIL"}},"next":{"fields":{"slug":"/study/하루3분 네트워크5/"},"frontmatter":{"title":"하루 3분 네트워크 스터디 5","category":"study"}}}},"staticQueryHashes":["3128451518","96099027"]}