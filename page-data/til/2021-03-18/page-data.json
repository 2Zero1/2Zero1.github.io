{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/2021-03-18/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"0e6bbc19-405c-5b3f-b94d-ee6536e0979d","excerpt":"fact 리액트 훅에 문서를 읽었고, 클래스가 함수형으로 사용되면서 생명주기가 어떻게 달라지는지 공부했다. 프로젝트 기획서를 만들고, 테스트목록인 기능목록을 만들었다. 프로 자바스크립트 테크닉 60 ~ 90p 읽었다. 하체 운동을 했다. 토할뻔 했다. 나는 하체를 할때 허벅지로 피쏠림 현상이 심해서 그런지 엄청 울렁거린다. feelings 오랜만에 강의가 아니라, 내가 진행할 프로젝트를 고민해서 재미있었다. 이전에 일하던 곳에서 정말 잘 배웠다고 생각한다. 프로 자바스크립트 책에 dom…","html":"<ol>\n<li>\n<p>fact</p>\n<ul>\n<li>리액트 훅에 문서를 읽었고, 클래스가 함수형으로 사용되면서 생명주기가 어떻게 달라지는지 공부했다.</li>\n<li>프로젝트 기획서를 만들고, 테스트목록인 기능목록을 만들었다.</li>\n<li>프로 자바스크립트 테크닉 60 ~ 90p 읽었다.</li>\n<li>하체 운동을 했다. 토할뻔 했다. 나는 하체를 할때 허벅지로 피쏠림 현상이 심해서 그런지 엄청 울렁거린다.</li>\n</ul>\n</li>\n<li>\n<p>feelings</p>\n<ul>\n<li>오랜만에 강의가 아니라, 내가 진행할 프로젝트를 고민해서 재미있었다. 이전에 일하던 곳에서 정말 잘 배웠다고 생각한다.</li>\n<li>프로 자바스크립트 책에 dom 부분을 읽는데, 번역이 너무 어렵게 되어있다. dom을 깨우치다가 번역은 훨씬 좋았다.</li>\n<li>계속 조금씩 늦장을 부리는것 같아서 조금 아쉽다. 아침에도 일어나면 바로 일어나는게 아니라 뭔가 뒤척이다 어쩔 수 없이 일어나는 느낌이라고 해야될까 .. ? </li>\n</ul>\n</li>\n<li>\n<p>finding</p>\n<ul>\n<li>\n<p>코드숨</p>\n<ul>\n<li>useEffect</li>\n<li>함수 컴포넌트에서 side effect를 수행할 수 있게 해준다.</li>\n<li>sideEffect는 데이터 가져오기, 구독 설정, 수동으로 리액트 컴포넌트의 dom 수정 등이 있다.</li>\n<li>매번의 렌더링과, 모든 업데이트에서 수행된다. 리액트는 useEffect가 수행되는 시점에 이미 DOM이 업데이트 되었음을 보장한다.</li>\n<li>리렌더링을 할 때마다 이전과 다른 effect로 교체하여 전달한다??</li>\n<li>이는 클래스 형의 componenetDidmount와 componenetupdatemount를 대신해준다.</li>\n<li>useEffect를 사용하여 componenetDidmount 할 땐 return 값으로 실행할 함수 블록을 넘겨준다.</li>\n</ul>\n</li>\n<li>\n<p>프로 자바스크립트 테크닉</p>\n<ul>\n<li>5장 문서 객체 모델</li>\n<li>script 태그는 body 태그 이후에 나와야 한다. script에는 이미지, 음성, 비디오, css 등 뿐만 아닌 HTML를 로드한다. 그래서 script가 body태그 앞에 나올 경우, 브라우저는 로딩 하는 동안에 화면을 그리지 않는다.</li>\n<li>\n<p>DOM 구조</p>\n<ul>\n<li>HTML 문서의 구조는 DOM을 써서 탐색할 수 있는 트리로 표현한다.</li>\n<li>트리의 몸통은 Document Node 인데, Document element라고도 부른다.</li>\n<li>각각의 노드는 부모나 다른 자손 또는 그들의 자식을 가리키는 포인터를 갖는다.</li>\n<li>DOM 트리 내의 모든것은 노드이다</li>\n<li>html</li>\n<li>문자</li>\n<li>주석</li>\n<li>DOCTYPE</li>\n<li>속성</li>\n<li>각각의 노드는 적절히 nodeType이라고 불는 노드 유형 속성을 가지며 이 속성을 검색하여 원하는 종류의 유형을 알아낼 수 있다.</li>\n<li>노드 유형 각각은 구현된 유형이 있으며, Document, Element, Atrr및 Text 들이다.</li>\n<li>일반적으로 Document는 HTML 문서를 전체적으로 관리한다.</li>\n<li>문서 내에서의 각 꼬리표는 Element이다.(HTMLElement, HTMLForElement)</li>\n<li>요소의 속성은 Attr의 인스턴스, Element 내의 일반 문자는 문자 노드로 Text 유형으로 나타낸다. 하지만 Text 노드는 보조 유형으로 Node로 부터 상속된 유형은 아니다.</li>\n</ul>\n</li>\n<li>\n<p>DOM 관계</p>\n<ul>\n<li>모든 단일 노드는 친척을 참조할 수 있는 포인터 집합을 가진다.</li>\n<li>모든 DOM 노드에서 가용한 이런 각 속성은 또 다른 Node나 부속 클래스를 가리키는 포인터다. 하지만 예외로 childNodes는 자식 노드들을 유사 배열로 갖는다.</li>\n<li>루트 노드는 다른 DOM 녿와 마찬가지로 탐색에 쓰이는 일체의 노드를 갖는다.</li>\n<li>DOM 포인터는 문자 노드와 요소 모두를 가리킬 수 있다.</li>\n<li>\n<div> <span>hello</span></div>\n</li>\n<li>위의 태그에서 div의 firstChild는 공백을 갖는 문자 노드이다.</li>\n<li>줄바꿈 또한 문자 노드가 될 수 있다.</li>\n<li>따라서 DOM 포인터만 갖고 대부분 탐색하는것은 굉장히 어렵다.</li>\n<li>현대적인 DOM 인터페이스</li>\n<li>\n<p>getElementById</p>\n<ul>\n<li>document에서만 동작하며, 모든 dom에서 동일한 id를 찾는다.</li>\n<li>element 유형의 인스턴스에는 쓸 수 없고, Document 유형에만 가능</li>\n</ul>\n</li>\n<li>\n<p>getElementByTagName</p>\n<ul>\n<li>모든 element가 사용할 수 있으며, 쿼리 범위를 설정할 수 있음.</li>\n<li>활성 NodeList를 반환</li>\n</ul>\n</li>\n<li>\n<p>getElementByClassName</p>\n<ul>\n<li>모든 element가 사용할 수 있으며, 쿼리 범위를 설정할 수 있음.</li>\n<li>활성 HTMLCollection을 반환</li>\n<li>\n<p>활성(live)</p>\n<ul>\n<li>DOM이 수정될 경우 내용이 DOM에 반영되며, 이전에 활성 List로 받은 것들 또한 업데이트 됨.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>위의 두 메서드가 반환하는 타입이 다른데, 접근하는 패턴은 사실 같음.</li>\n<li>CSS 선택자로 원소 찾기</li>\n<li>CSS 선택자는 일련의 원소들의 집합에 CSS 스타일을 적용하는데 쓰이는 표현식</li>\n<li>\n<p>CSS 선택자로 원소에 접근하는 방식</p>\n<ul>\n<li>querySelector</li>\n<li>선택자와 일치하는 첫번째 원소를 찾아 반환.</li>\n<li>querySelectorAll</li>\n<li>선택자와 일치하는 모든 원소를 찾아 활성(live)가 아닌 NodeList를 반환</li>\n</ul>\n</li>\n<li>단일 원소 접근 -> document.getElementById</li>\n<li>여러 원소 -> getElementsByTagName -> getElementByClassName -> querySelectorAll</li>\n<li>페이지 로드 될 때까지 대기하기</li>\n<li>\n<p>HTML DOM 문서로 작업 할땐 DOM이 로드되기전에 js를 실행할 수 있기 때문에 문제가 발생함.</p>\n<ol>\n<li>HTML 분석</li>\n<li>외부 스타일 시트 로드</li>\n<li>문서에서 스크립트가 분석되고 실행</li>\n<li>HTML DOM이 완전히 구성됨</li>\n<li>이미지와 외부 컨텐츠가 로드됨</li>\n<li>페이지 로딩이 끝난다.</li>\n</ol>\n</li>\n<li>\n<p>헤드에 있거나 외부 파일로 부터 로드된 스크립트는 HTML DOM 이 실질적으로 구성되기 전에 실행되며 이런 두 지점에서 실행되는 스크립트는 DOM 에 접근하지 못하기 때문에 문제가 된다.</p>\n<ul>\n<li><strong>근데 body뒤에 script를 두는 이유가 script를 로드할 때 브라우저가 문서를 그리지 않아서 그런거라고 했는데 ? 저렇게 하면 DOM을 구성하고 그리는게 아닌가 ? 내 생각에 script가 body 태그가 끝나기 전에 있을 때의 상황을 이야기하는 것 같음.</strong></li>\n</ul>\n</li>\n<li>페이지가 로드될 때 윈도우 객체에 로드 이벤트를 띄우면 위의 문제를 해결할 수 있다. load는 브라우저가 js(이미지, 비디오, 무거운 것들)을 모두 로딩하고 그린 후에 load를 부른다. 그래서 굉장히 느리다.</li>\n<li>\n<p>DOMContentLoaded 이벤트 사용.</p>\n<ul>\n<li>문서만 로드 되고 분석한 다음 발생한다.</li>\n<li>HTML DOM이 완전히 구성될때 불린다는 말이다.</li>\n<li>하지만 이걸 사용해도 js가 아직 다 못받을 수도 있으니, window.load를 같이 쓰면 된다.</li>\n</ul>\n</li>\n<li>Element 내용 얻기</li>\n<li>DOM 원소에 들어갈 수 있는 것은 문자, 여러 원소, 문자와 원소의 조합의 세가지 중 하나다.</li>\n<li>\n<p>원소안에 있는 문자를 담거나 가져오는 방법</p>\n<ul>\n<li>모질라가 아닌 브라우저</li>\n<li>object.innerText</li>\n<li>모질라가 아닌 브라우저를 포함한 일체의 플랫폼</li>\n<li>object.firstChild.nodeValue</li>\n</ul>\n</li>\n<li>원소로부터 HTML 얻기</li>\n<li>innerHtml은 원소 내에서 HTML과 문자를 텍스트로 얻는다.</li>\n<li>하지만 모질라 기반 브라우저는 style 원소를 반환하지 않는다 ?</li>\n<li>innerHTML에 태그를 포함해서 넣으면, HTML 파서가 해석해서 태그로 넣는다..</li>\n<li>원소가 오로지 문자만 갖고 있다 확신한다면 이 방법이 좋다.</li>\n<li>원소로 부터 HTML 내용을 얻어 편집하는 것은 신선하게 동적으로 처리하는 APP을 만들 수 있다.</li>\n<li>Element의 속성 이용하기</li>\n<li>element.attributes로 접근할 수 있으며, 이름/값 형식의 속성 쌍으로 수집된 적당한 배열을 갖게된다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Future Action Plan</p>\n<ul>\n<li>전체적으로 운동해야겠다.</li>\n<li>디자인을 해야한다 ..</li>\n<li>저녁에 휴대폰하다가 너무 늦게 잔다. 휴대폰 사용 제한시간을 정해서 하지 말아야겠다.</li>\n<li>프로젝트를 위한 밑기반 작업을 한다.</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"2021-03-18 TIL","date":"March 18, 2021"}}},"pageContext":{"slug":"/til/2021-03-18/","previous":{"fields":{"slug":"/til/2021-03-17/"},"frontmatter":{"title":"2021-03-17 TIL","category":"TIL"}},"next":{"fields":{"slug":"/study/하루3분 네트워크5/"},"frontmatter":{"title":"하루 3분 네트워크 스터디 5","category":"study"}}}},"staticQueryHashes":["3128451518","96099027"]}