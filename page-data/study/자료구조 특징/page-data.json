{"componentChunkName":"component---src-templates-blog-post-js","path":"/study/자료구조 특징/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"252a3644-6e40-5014-af20-7e0ee5f95b29","excerpt":"c언어로 작성된 프로그램은 세가기 종류의 영역을 가진다. 전역변수나 정적 변수등이 저장되는 static memory 지역 변수가 저장되는 automatic memory free store static memory는 프로그램이 실행하면서 프로그램에서 사용될 전역 변수/정적 변수를 메모리에 할당한 후 프로그램이 종료될 때 해제하는 영역이다. 자동 메모리는 스택 구조로 이루어져 있어 이곳에 저장된 변수는 코드 블록이 종료됨에 따라 메모리에서 없어진다.\nfree store는 automatic memory…","html":"<p>c언어로 작성된 프로그램은 세가기 종류의 영역을 가진다.</p>\n<ol>\n<li>전역변수나 정적 변수등이 저장되는 static memory</li>\n<li>지역 변수가 저장되는 automatic memory</li>\n<li>free store</li>\n</ol>\n<p>static memory는 프로그램이 실행하면서 프로그램에서 사용될 전역 변수/정적 변수를 메모리에 할당한 후 프로그램이 종료될 때 해제하는 영역이다.</p>\n<p>자동 메모리는 스택 구조로 이루어져 있어 이곳에 저장된 변수는 코드 블록이 종료됨에 따라 메모리에서 없어진다.\nfree store는 automatic memory와 달리 프로그래머가 직접 메모리를 관리하는 메모리 영역이다. 그래서 자유롭게 메모리를 할당해서 사용할 수 있지만 그 메모리를 안전하게 해제해야한다.</p>\n<p>Token\n텍스트 분석에서의 토큰은 ‘최소 단위의 기호 또는 단어’를 말한다.</p>\n<h2 id=\"list리스트\" style=\"position:relative;\"><a href=\"#list%EB%A6%AC%EC%8A%A4%ED%8A%B8\" aria-label=\"list리스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>List(리스트)</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 배열처럼 데이터 집합을 보관하는 기능을 가지면서도 한편으로는 배열과는 달리 유연하게 크기를 바꿀 수 있는 자료구조이다.\n- 노드의 생성/소멸, 추가, 삭제, 삽입은 링크드 리스트 자료구조를 구축하기 위한 연산이고, 리스트 탐색은 구축되어 있는 링크드 리스트의 데이터를 활용하기 위한 연산이다.\n- pros&amp;cons\n  - pros\n    1. 새로운 노드의 추가/삽입/삭제가 쉽고 빠르다.(삭제 또는 삽입을 하기 위해선 최대 n번의 계산이 필요한데?)\n  - cons\n    1. 다음 노드를 가리키려는 포인터 때문에 각 노드마다 4byte의 메모리가 추가로 필요하다.\n    2. 특정 위치에 있는 노드를 얻는데 비용이 크며 속도도 느리다.(탐색). 노드의 개수가 n이라면 최악의 경우 n회의 노드 탐색 루프를 실행해야 특정 위치에 있는 노드를 찾을 수 있다.\n\n- 따라서 링크드 리스트가 사용되기에 적합한 곳은 레코드의 추가/삽입/삭제가 잦고 조회는 드문곳이다.\n- doubly linked list\n  - 위의 singly linked list의 탐색 기능을 개선한 자료구조이다.\n  - head와 tail을 알고 있어 양방향 탐색이 가능하다. 그래서 맨 마지막에 있는 데이터를 처음부터 찾을 필요가 없다.\n- 환형 링크드 리스트\n  - 테일의 다음 노드 포인터가 헤드를 가리키고 헤드의 이전 노드가 테일을 가리키게 하는 리스트(doubly linked list일 경우)\n  - 테일에 접근하는 비용이 거의 없는것이나 다름 없을 정도로 작아져 리스트의 마지막에 넣는 함수인 append 성능을 개선시킬 수 있고, 뒤에서부터 노드를 찾아 나가는 노드 탐색 루틴을 구현할 수도 있다.</code></pre></div>\n<h2 id=\"stack\" style=\"position:relative;\"><a href=\"#stack\" aria-label=\"stack permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>stack</h2>\n<ul>\n<li>First In, Last Out</li>\n<li>\n<p>오퍼레이션 종류</p>\n<ol>\n<li>push</li>\n<li>pop</li>\n</ol>\n</li>\n<li>\n<p>종류</p>\n<ol>\n<li>배열을 이용한 스택</li>\n<li>공적으로 스택의 용량을 조절하기 어렵지만 구현이 간단하다.</li>\n<li>리스트를 이용한 스택</li>\n<li>스택의 용량에 제한을 두지 않아도 된다.</li>\n</ol>\n</li>\n<li>\n<p>사용 예</p>\n<ol>\n<li>reverse polish Notation</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"queue\" style=\"position:relative;\"><a href=\"#queue\" aria-label=\"queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>queue</h2>\n<ul>\n<li>queue는 데이터 입력이 폭주할때 먼저 입력 받은 데이터의 처리가 끝나지 않았는데 그 뒤에 새로운 데이터가 마구 입력되면 그 데이터들은 보관할 장소가 따로 없으므로 버려야 한다. 이럴때 밀려드는 데이터를 보관할 장소로 큐가 필요하다.</li>\n<li>buffer와 비슷하다.</li>\n<li>First In First Out 의 특징을 갖고 있다.</li>\n<li>\n<p>순환큐</p>\n<ul>\n<li>큐를 배열로 구현하면 dequeue를 할 경우 맨 앞의 빈자리를 채우기 위해 뒤의 요소들을 모두 옮겨야 되는 문제가 발생한다. 그래서 전단을 가리키는 변수를 도입해서, 배열 내의 요소를 옮기는 대신 변경된 전단의 위치만 관리한다. 또 후단을 가리키는 변수도 도입해서 삽입이 일어날 때마다 변경되는 후단의 위치를 관리한다.</li>\n<li>하지만 위에서 말한 큐 또한 몇번의 dequeue로 전단과 후단이 가까워지고 후단이 들어갈 공간이 몇개 남지 않은 경우, 후단이 배열의 앞에서 다시 시작하도록 만들 수 있다.</li>\n<li>여기까지 한 것으론 순환큐가 가득차있는 상태와 빈 상태를 구분할 수 없다. 둘다 같은 요소를 가리킬 것이기 때문이다. 필요한 배열 요소 개수 + 1 개를 만들어 놓고 후단이 실제 후단에 1을 더한 값을 가지게 한다.</li>\n<li>그래서 큐가 비어있을땐 전단과 후단이 같은곳을 가리키고, 큐가 차있을땐 후단이 전단보다 -1 작은 값을 갖게 된다.</li>\n</ul>\n</li>\n<li>\n<p>링크드 큐</p>\n<ul>\n<li>순환큐는 개념도 복잡하고, 구현도 쉽지 않다.</li>\n<li>링크드 큐는 비교적 단순하다. 하지만 성능은 순환큐가 빠르다. 노드를 생성하고 삭제하기 위해 malloc()을 호추할 필요가 없기 때문이다.</li>\n<li>큐의 크기가 예측가능하고 고성능이 필요한 버퍼와 같은 사례에서는 링크드 큐보다는 순환 큐가 더 적절하다.</li>\n<li>링크드 큐는 가득차있는 상태인지 확인할 필요가 없다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"tree\" style=\"position:relative;\"><a href=\"#tree\" aria-label=\"tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TREE</h2>\n<p>조직도 같은 계층적인 데이터를 표현하는데 사용되고, 수식을 표현할때도 사용된다. 또한 집합을 나타내는 데 사용되며, 심지어는 데이터의 탐색을 위한 트리도 있다.</p>\n<h3 id=\"사용-예\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9-%EC%98%88\" aria-label=\"사용 예 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용 예</h3>\n<ol>\n<li>운영체제의 파일 시스템</li>\n<li>HTML이나 XML문서를 다룰떄 사용하는 DOM(Document Object Model)</li>\n<li>검색 엔진이나 데이터베이스(탐색 트리)</li>\n</ol>\n<h3 id=\"구성요소\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C\" aria-label=\"구성요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구성요소</h3>\n<ol>\n<li>root : 트리의 가장 위에 있는 노드</li>\n<li>branch : 루트와 잎 사이에 있는 모든 노드</li>\n<li>leaf : 끝에 있으며 단말(Terminal)노드라고도 함.</li>\n</ol>\n<h3 id=\"관계\" style=\"position:relative;\"><a href=\"#%EA%B4%80%EA%B3%84\" aria-label=\"관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>관계</h3>\n<ol>\n<li>parent: 노드의 부모를 가리킴</li>\n<li>children: 노드의 자식을 가리킴</li>\n<li>sibling: 같은 부모에 있는 node들을 가리킴</li>\n</ol>\n<h3 id=\"용어\" style=\"position:relative;\"><a href=\"#%EC%9A%A9%EC%96%B4\" aria-label=\"용어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>용어</h3>\n<ol>\n<li>path: 트리에서 경로는 한 노드에서부터 다른 한 노드까지 이르는 길 사이에 놓여있는 노드들의 순서이다.(a -> b -> c)</li>\n<li>length: 그저 출발 노드에서 목적지 까지 거쳐야 하는 노드의 개수를 말한다.(B -> D -> F 경로의 길이는 2가 된다.)</li>\n<li>depth: 루트 노드에서 해당 노드까지의 경로의 길이를 뜻한다.(length와의 차이가 뭘까 ?)</li>\n<li>level: 깊이가 같은 노드들의 집합을 일컫는 말이다.</li>\n<li>height: 루트에서 가장 깊은곳에 있는 잎노드 까지의 깊이를 뜻한다.</li>\n<li>Degree(차수): 노드의 자식 노드 개수, 트리의 차수는 트리내에 있는 노드들 가운데 자식 노드가 가장 많은 노드의 차수를 말한다.</li>\n</ol>\n<h3 id=\"트리의-표현-방법\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%A6%AC%EC%9D%98-%ED%91%9C%ED%98%84-%EB%B0%A9%EB%B2%95\" aria-label=\"트리의 표현 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트리의 표현 방법</h3>\n<ol>\n<li>Nested parenthesis(중첩된 괄호): 같은 레벨들의 노드들을 괄호로 같이 묶어 표현하는 방법이다. 이방법은 읽기 다소 어렵지만 트리를 하나의 공식처럼 표현할 수 있는 장점이 있다.</li>\n<li>Nested Set(중첩된 집합): 트리가 하위 트리의 집합이라는 관계를 잘 표현할 수 있다.</li>\n<li>Indentation(들여쓰기): 계층적인 특징을 잘 나타내며, 윈도우 탐색기의 폴더 트리가 들여쓰기로 표현한 트리의 좋은 예이다.</li>\n</ol>\n<h3 id=\"노드-표현하기\" style=\"position:relative;\"><a href=\"#%EB%85%B8%EB%93%9C-%ED%91%9C%ED%98%84%ED%95%98%EA%B8%B0\" aria-label=\"노드 표현하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드 표현하기</h3>\n<p>부모와 자식, 그리고 형제 노드를 서로 연결짓는 방법이다.</p>\n<ol>\n<li>\n<p>N-Link 표현법</p>\n<ul>\n<li>노드의 차수가 N이라는 의미이다.</li>\n<li>단점으로 차수가 0일 수도 수백 수만일수도 있다. 동적 메모리를 할당하여 가변 배열을 만들거나 링크드 리스트를 사용하면 해결할 수 있지만 너무 복잡해진다.</li>\n</ul>\n</li>\n<li>\n<p>LeftChild-Right Sibling표현법</p>\n<ul>\n<li>위에서 이야기한 N-Link 표현법의 문제를 해결해준다.</li>\n<li>이 방법을 이용하면 n개의 차수를 가진 노드의 표현이 두 개의 포인터, 왼쪽 자식-오른쪽 형제만으로 가능하다.</li>\n<li>이 표현법을 사용하는 트리에서 어느 한 노드의 모든 자식 노드를 얻으려면 일단 왼쪽 자식 노드에 대한 포인터만 있으면 된다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"이진-트리binary-tree\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%ACbinary-tree\" aria-label=\"이진 트리binary tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이진 트리(Binary tree)</h3>\n<p>모든 노드가 최대 2개의 자식을 가질 수 있는 트리이다. 일반 트리처럼 데이터를 담는 용도로는 사용하기가 곤란하지만, 역으로 이런 특별한 구조를 이용한 훌륭한 알고리즘들이 개발되어 있다. 수식을 트리 형태로 표현하여 계산해주는 수식 이진 트리(Expression Binary Tree)와 아주 빠른 데이터 검색을 가능케 하는 이진 탐색 트리(Binary Search Tree)가 있다.</p>\n<ol>\n<li>Full Binary Tree(포화 이진 트리)\n모든 노드들이 자식을 두명씩 가지며 잎 노드들이 모두 같은 깊이에 존재한다는것이 특징.</li>\n<li>Complete Binary Tree(완전 이진 트리)\n잎 노드들이 트리의 왼쪽부터 차곡차곡 채워진 것이 특징입니다.</li>\n</ol>\n<p>이진 트리는 일반 트리처럼 나무 모양의 자료를 담기 위한 자료구조가 아니라 컴파일러나 검색 등에 사용되는 특수 구조이다. 특히 이진 트리를 이용한 검색에서는 높은 성능을 위해 트리의 노드들을 가능한 한 ‘완전한’ 모습으로 배치하는것이 필수이다.</p>\n<p>비슷한 맥락의 이진트리의 상태를 분류하는 용어</p>\n<ol>\n<li>높이 균형 트리(Height Balanced Tree)\n루트 노드를 기준으로 왼쪽 하위 트리와 오른쪽 하위 트리의 높이가 1 이상 차이나지 않는 이진 트리를 일컫는 말.</li>\n<li>완전 높이 균형 트리(Completely Height Balanced Tree)\n완전 높이 균형 트리는 루트 노드를 기준으로 왼쪽 하위 트리와 오른쪽 하위 트리의 높이가 같은 이진 트리를 가리키는 말이다.</li>\n</ol>\n<h3 id=\"이진-트리의-순회traversal\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%88%9C%ED%9A%8Ctraversal\" aria-label=\"이진 트리의 순회traversal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이진 트리의 순회(Traversal)</h3>\n<p>순회는 트리 내의 노드들 사이를 돌아다니는 것을 말한다. 순회는 몇 가지 규칙에 근거해서 이진 트리 내부를 돌아다니며 효율적인 방법으로 원하는 데이터에 접근할 수 있는 방법을 제공한다.</p>\n<ol>\n<li>\n<p>Preorder Traversal(전위 순위)</p>\n<ul>\n<li>루트 노드부터 잎 노드까지 아래 방향으로 방문한다.</li>\n</ul>\n</li>\n<li>\n<p>Inorder Traversal(중위 순위)</p>\n<ul>\n<li>왼쪽 하위 트리부터 루트를 거쳐 오른쪽 하위 트리방향으로 방문한다.</li>\n</ul>\n</li>\n<li>\n<p>Postorder Traveral(후위 순위)</p>\n<ul>\n<li>왼쪽 하위트리 오른쪽 하위 트리를 거쳐 루트를 방문한다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"수식-트리expression-binary-tree\" style=\"position:relative;\"><a href=\"#%EC%88%98%EC%8B%9D-%ED%8A%B8%EB%A6%ACexpression-binary-tree\" aria-label=\"수식 트리expression binary tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수식 트리(Expression Binary Tree)</h3>\n<ol>\n<li>피연산자는 잎 노드이다.</li>\n<li>연산자는 루트 노드, 또는 가지 노드이다.</li>\n<li>피연산자는 수일수로 있고 또 다른 식일 수도 있다.</li>\n</ol>\n<h3 id=\"분리-집합disjoint-set\" style=\"position:relative;\"><a href=\"#%EB%B6%84%EB%A6%AC-%EC%A7%91%ED%95%A9disjoint-set\" aria-label=\"분리 집합disjoint set permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분리 집합(Disjoint Set)</h3>\n<p>분리 집합은 서로 공통된 원소를 갖지 않는 집합들을 말합니다. 따라서 교집합(intersection)이 있을 수 없다. 오직 union(합집합)만이 있다.</p>\n<p>분리 집합은 집합들 간의 교집합을 허락하지 않기 때문에 서로 구분되어야 하는 데이터 집합을 다룰 때 아주 유용하다.</p>\n<p>분리 집합은 원소 또는 개체가 ‘어느 집합에 소속되어 있는가?’ 라는 정보를 바탕으로 하는 알고리즘에 응용할 수 있다. 한 원소가 소속되어 있는 집합을 알아내는 것을 집합 탐색이라고 한다.</p>\n<p>일반 트리나 이진 트리는 모두 부모가 자식을 가리키는 포린터를 갖지만 분리 집합은 이와는 반대로 자식이 부모를 가리킨다.</p>\n<p>분리집합의 연산</p>\n<ol>\n<li>\n<p>합집합</p>\n<ul>\n<li>구현방법으로 귀속될 집합의 부모의 parent 노드를 귀속할 집합의 부모를 가리키게 하면된다.</li>\n</ul>\n</li>\n<li>\n<p>집합 탐색</p>\n<ul>\n<li>집합에서 원소를 찾는것이 아니라, 원소가 속해 있는 집합을 찾는 연산이다.</li>\n<li>집합 내의 어떤 노드든 루트 노드가 나타내는 집합이 곧 자신이 속해 있는 집합이므로, 해당 원소(노드)가 어떤 집합에 속해 있는지 알려면 이 원소가 속해 있는 트리의 루트 노드를 찾으면 된다.\n다른 연산이 필요하지 않는 이유는 <strong><em>분리 집합의 목적이 원소가 어느 집합에 귀속되어 있는지를 쉽게 알아낼 수 있도록 하는데 있기 때문이다.</em></strong></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"hash-table\" style=\"position:relative;\"><a href=\"#hash-table\" aria-label=\"hash table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hash Table</h2>\n<p>해시테이블은 이진 탐색보다 빠른 성능을 자랑하지만, 그 성능을 위해 더 많은 메모리를 필요로 한다.</p>\n<p>데이터를 담을 테이블을 미리 크게 확보해 놓은 후 입력받은 데이터를 해시하여 테이블 내의 주소를 계산하고 이 주소에 데이터를 담는것, 이것이 해시 테이블의 기본 개념이다. 해시테이블의 성능은 공간을 더 사용해 얻어낸 것이다.</p>\n<p>해시테이블은 데이터가 입력되지 않은 여유 공간이 많아야 제 성능을 낼 수 있다.</p>\n<h3 id=\"해시란\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C%EB%9E%80\" aria-label=\"해시란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시란?</h3>\n<p>데이터를 입력받으면 완전히 다른 모습의 데이터로 바꾸어 놓는 작업</p>\n<h3 id=\"해시의-용도\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C%EC%9D%98-%EC%9A%A9%EB%8F%84\" aria-label=\"해시의 용도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시의 용도</h3>\n<ol>\n<li>해시테이블\n해시 테이블은 데이터의 해시 값을 테이블 내의 주소로 이용하는 궁극의 탐색 알고리즘이다.(공간을 팔아 시간을 사다.)</li>\n<li>암호화\n해시를 통해 변환된 데이터는 원본의 모습을 알아볼 수 없을 정도로 달라지는데 이 특성을 이용하여 암호화 영역에서 사용되고 있다. sha(secure hash algorithm)이 대표적인 예이다.</li>\n<li>데이터 축약\n해시는 길이가 서로 다른 입력 데이터에 대해 일정한 길이의 출력을 만들 수 있다. 축약된 데이터 끼리 비교를 수행하면 커다란 원본 데이터들을 비교하는 것에 비해 엄청난 효율을 거둘 수 있다.</li>\n</ol>\n<h3 id=\"해시-함수\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98\" aria-label=\"해시 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시 함수</h3>\n<p>입력 값에서 테이블 내의 주소를 계산해내는 함수이다.</p>\n<ol>\n<li>나눗셈법\n입력값을 테이블의 크기로 나누고, 그 ‘나머지’를 테이블의 주소로 사용한다. 나눗셈법으로 구현된 해시 함수가 테이블 내의 공간을 효율적으로 사용하기 위해서는 테이블의 크기 n을 소수(prime Number)로 정하는 것이 좋다고 알려져 있다.</li>\n<li>자릿수 접기\n서로 다른 입력값에 대해 동일한 해시 값, 즉 해시 테이블 내의 동일한 주소를 반환할 가능성이 높다. 이것을 충돌(collision)이라고 하며, 설사 같은 해시 값이 아니더라도 해시 테이블 내의 일부 지역의 주소들을 집중적으로 반환하는 결과로 데이터들이 한 곳에 모이는 문제(cluster)가 발생할 가능성도 높다. collision 이나 clustering을 완벽하게 제거할 수 있는 해싱 알고리즘은 없지만 문제를 일으킬 가능성을 줋이는 알고리즘이 있으며 그중의 하나를 자릿수 접기(digits folding)이라 한다.</li>\n</ol>\n<p>  숫자 8 1 2 9 3 3 5가 있다고 하면, 82 + 29 + 33 + 5 와 같이 숫자의 각 자릿수를 더해 해시값을 만드는 것을 자릿수 접기라고한다.</p>\n<p>  자릿수 접기는 문자열을 키로 사용하는 해시 테이블에 특히 잘 어울리는 알고리즘이다.</p>\n<h3 id=\"충돌-해결하기\" style=\"position:relative;\"><a href=\"#%EC%B6%A9%EB%8F%8C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-label=\"충돌 해결하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>충돌 해결하기</h3>\n<p>어떤 해시 함수든, 그 알고리즘이 정교하더라도 모든 입력 값에 대해 고유한 해시 값을 만들진 못한다. 해시함수의 충돌은 피할수 없다.</p>\n<p>충돌을 해결하는 방법으로 크게 2가지 방법이 있으며 해시테이블의 주소 바깥에 새로운 공간을 할당하여 문제를 해결하는 개방 해싱(open hashing)과 처음에 주어진 해시 테이블의 공간 안에서 문제를 해결하는 폐쇄 해싱(closed hashing)이 있다.</p>\n<h4 id=\"체이닝\" style=\"position:relative;\"><a href=\"#%EC%B2%B4%EC%9D%B4%EB%8B%9D\" aria-label=\"체이닝 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>체이닝</h4>\n<p>체이닝은 해시 함수가 서로다른 키에 대해 같은 주소값을 반환해서 충돌이 발생하면 각 데이터를 해당 주소에 있는 링크드 리스트에 삽입하여 문제를 해결하는 기법이며 개방 해싱 알고리즘이다.</p>\n<p>해시 함수가 만들어낸 주소값을 데이터가 직접 사용하지 않고 링크드 리스트가 사용한다는 것 말고는 해시 함수의 역할이 같다. 하지만 데이터를 해시 테이블에 삽입하고 탐색하는 연산은 새 알고리즘에 맞춰 바꿔야한다. 그래서 탐색 연산은 ‘충돌이 발생했을’ 것을 고려해서 설계해야한다.</p>\n<p>데이터가 삽입될 링크드 리스트의 주소를 얻어낸 후에, 링크드 리스트가 비어 있으면 데이터를 바로 삽입하고 그렇지 않은 경우에는 링크드 리스트의 ‘헤드 앞에’ 삽입한다. 헤드에 삽입하는 이유는 테일에 만약에 삽입하게 되면, tail을 찾는 순차 탐색을 수행해야하기 때문이다.</p>\n<h3 id=\"체이닝의-문제-해결하기\" style=\"position:relative;\"><a href=\"#%EC%B2%B4%EC%9D%B4%EB%8B%9D%EC%9D%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-label=\"체이닝의 문제 해결하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>체이닝의 문제 해결하기</h3>\n<p>chainning은 원하는 데이터를 찾기 위해 순차 탐색을 해야 하는 링크드 리스트의 단점을 고스란히 갖는다.</p>\n<h4 id=\"개방-주소법open-addressing\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EB%B0%A9-%EC%A3%BC%EC%86%8C%EB%B2%95open-addressing\" aria-label=\"개방 주소법open addressing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개방 주소법(open addressing)</h4>\n<p>  충돌이 일어날 때 해시 함수에 의해 얻어진 주소가 아니더라도 얼마든지 다른 주소를 사용할 수 있도록 허용하는 충돌 해결 알고리즘\n오픈 해싱 기법인 동시에 폐쇄 주소법(closed addressing)알고리즘 이기도 하다.\n개방 주소법은 충돌이 일어나면 해시 테이블 내의 새로운 주소를 탐사하여 충돌된 데이터를 입력하는 방식으로 동작한다.\n탐사가 핵심이다.</p>\n<ol>\n<li>선형탐사\n해시 함수로 부터 얻어낸 주소에 이미 다른 데이터가 있을 경우, 현재 수소에서 고정폭(예를 들어 1)으로 다음 주소로 이동. 그 주소에도 다른 데이터가 있어 충돌이 발생하면 또 그 다음 주소로 이동한다. 이렇게 비어 있는 주소를 찾아내면 그곳에 데이터를 입력한다.</li>\n<li>제곱탐사\n선형 탐사와 기본 개념은 다르지 않으며 고정 폭만큼 이동하는 것에 비해 이동폭이 곱수로 늘어난다.\n제곱탐사는 서로 다른 해시값을 갖는 데이터에 대해서는 클러스터가 형성되지 않도록 하는 효과가 있지만, 같은 해시 값을 갖는 데이터에 대해서는 2차 클러스터를 형성하도록 유도하는 문제를 갖고 있다.</li>\n<li>이중 해싱(double hashing)\n2개의 해시 함수를 준비해서 하나는 최초의 주소를 얻을 때 또 다른 하나는 충돌이 일어났을 때 탐사 이동폭을 얻기 위해 사용한다.\n제곱탐사의 2차 클러스터를 형성하는 문제를 해결하여 탐사 이동폭의 규칙성은 없애면서도 같은 키에 대해서는 항상 똑같은 결과를 얻을 수 있다.</li>\n<li>재해싱\n아무리 성능이 뛰어난 충돌 해결 알고리즘도 해시 테이블의 여유 공간이 모두 차버리면 성능저하가 생긴다.\n재해싱은 해시 테이블의 크기를 늘리고, 늘어난 해시 테이블의 크기에 맞추어 테이블 내의 모든 데이터를 다시 해싱한다. 통계적으로 공간 사용률이 70 ~ 75에 이르면 성능 저하가 나타나므로 이쯤에 재해싱을 해준다. 하지만 재해싱 역시 만만치 않은 오버헤드를 요구하기 때문에 임계치를 너무 낮게 잡으면 성능저하가 온다.</li>\n</ol>\n<h2 id=\"graph\" style=\"position:relative;\"><a href=\"#graph\" aria-label=\"graph permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Graph</h2>\n<h3 id=\"특징\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95\" aria-label=\"특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h3>\n<p>그래프는 ‘정점의 모음’과 이 정점을 잇는 ‘간선의 모음’과의 결합이다.(정점의 집합을 V, 간선의 집합을 E, 그리고 그래프를 G라고 했을 때, G = (V, E)이다.)</p>\n<p>정점 몇 개 자체로는 아무것도 아니지만 이들이 간선으로 인해 서로 연결될 때는 ‘관계’가 형성되고 이로 인해 그래프가 형성된다.</p>\n<p>간선으로 연결되어 있는 두 정점을 가리켜 서로 인접(adjacent) 또는 이웃 관계에 있다고 말한다.</p>\n<p>어떤 정점 a에서 c까지 a,b,c가 있다면 이를 하나의 경로(path)를 이룬다. 경로는 길이를 가지는데, 길이는 정점과 정점 사이에 있는 간선의 수로 정의된다.</p>\n<p>어느 경로가 정점 하나를 두 번 이상 거치도록 되어있으면 그 경로를 일컬어 ‘사이클(cycle)이라고 말한다.</p>\n<p>간선이 방향성을 가지면 그래프는 다음과 같은 방향성 그래프(Directed Graph)가 되고, 반대로 간선에 방향성이 없으면 무방향성 그래프(undirected Graph)가 된다.</p>\n<p>무방향성 그래프 내의 두 정점 사이에 경로(Path)가 존재하면 이 두 정점이 연결되어 있다고 하며, 그래프 내의 각 정점들이 다른 모든 정점들과 연결되어 있으면 이 그래프는 연결되어 있다고 한다. 연결성(connectivity)는 정점과 그래프 양쪽에 사용될 수 있으면서도 어느 쪽에 사용되느냐에 따라 의미는 조금 달라진다.</p>\n<p>그래프는 정점 집합과 간선 집합의 결합이기 때문에, 이를 표현하는 문제는 ‘정점의 집합’과 ‘간선의 집합’의 표현 문제로 생각할 수 있다.</p>\n<p>간선은 정점과 정점이 ‘인접’관계에 있음을 나타내는 존재이다. 결국 그래프의 표현 문제는 ‘간선, 즉 정점과 정점의 인접 관계를 어떻게 나타내는가?‘의 문제로 귀결된다. 정점 사이의 인접 관계를 나타내는 방법에는 행렬을 이용하는 인접 행렬(adjacency matrix)와 리스트를 이용하는 인접리스트(adjcency list)가 있다.</p>\n<h3 id=\"인접-행렬\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EC%A0%91-%ED%96%89%EB%A0%AC\" aria-label=\"인접 행렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인접 행렬</h3>\n<p>그래프의 정점의 수를 N이라고 한다면 N * N 크기의 행렬을 만들어 행렬의 각 원소를 한 정점과 또 다른 정점이 인접해 있는 경우(즉, 정점 사이에 간선이 존재하는 경우)에는 1로 표시하고 인접해 있지 않는 경우 0으로 표시한다.</p>\n<p>인접 행렬이 주 대각선에 대해 대칭을 이루고 있으며, 무방향성인 경우 인접 행렬은 주 대각선에 대해 대칭을 이루는 것이 특징이다.</p>\n<h3 id=\"인접-리스트\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EC%A0%91-%EB%A6%AC%EC%8A%A4%ED%8A%B8\" aria-label=\"인접 리스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인접 리스트</h3>\n<p>그래프 내의 인접 관계를 표현하는 리스트이다.</p>\n<p>인접 행렬과 인접 리스트 중 어느 것을 사용해도 그래프의 인접 관계를 나타내는 데에는 문제가 없다.\n인접 행렬을 이용하면 정점 간의 인접 여부를 빠르게 알 수 있지만, 인접 관계를 행렬 형태로 저장하기 위해 사용하는 메모리의 양이 ‘정점의 크기* N^2’에 이른다는 단점이 있다. 인접 리스트는 정점 간의 인접 여부를 알아내기 위해 인접 리스트를 타고 순차 탐색을 해야 한다는 단점이 있는 반면, 정점과 간선의 삽입이 빠르고 인접 관계를 표시하는 리스트에 사용되는 메모리의 양이 적다는 장점이 있다.\n따라서 그래프 내의 정점의 수가 많지 않거나 정점끼리의 인접 여부를 빠르게 알아내야 한다면 인접 행렬을 사용하면 되고, 정점과 간선의 입력이 빈번하게 이루어지고 메모리 효율성을 우선시 해야 한다면 인접 리스트를 사용하면 된다.</p>","frontmatter":{"title":"자료구조 특징","date":"February 04, 2020"}}},"pageContext":{"slug":"/study/자료구조 특징/","previous":{"fields":{"slug":"/til/2020-02-03/"},"frontmatter":{"title":"2020-02-03 TIL","category":"TIL"}},"next":{"fields":{"slug":"/til/2020-02-04/"},"frontmatter":{"title":"2020-02-04 TIL","category":"TIL"}}}},"staticQueryHashes":["3128451518","96099027"]}