{"componentChunkName":"component---src-templates-blog-post-js","path":"/study/하루3분 네트워크5/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"c173fc86-c390-5532-bdda-547b3fa6ed4d","excerpt":"4계층의 역할과 개요 TCP…","html":"<ol>\n<li>\n<p>4계층의 역할과 개요</p>\n<ul>\n<li>\n<p>TCP</p>\n<ol>\n<li>\n<p>에러복구</p>\n<ul>\n<li>\n<p>세그먼트를 수신하면 수신한 것을 송신처에게 전달하는 것을 응답확인이라고 함.</p>\n<ul>\n<li>확인 응답 번호로 다음에 받을 데이터 번호를 알린다.</li>\n</ul>\n</li>\n<li>시퀀스 번호는 보내는 데이터의 앞 부분에 있는 옥텟 번호이고, 확인응답 번호는 다음에 받고 싶은 데이터의 선두 옥텟 번호이다.</li>\n</ul>\n</li>\n<li>흐름제어</li>\n<li>\n<p>커넥션을 맺는다.</p>\n<ul>\n<li>데이터를 통신하기 전에 사전에 가상 통신로를 확보하는 것.</li>\n<li>\n<p>커넥션 확립 과정</p>\n<ol>\n<li>통신로를 확보하기 위해 상대에게 데이터 전송의 허가 요청을 함.</li>\n<li>그것에 대한 허가를 송신처에게 알림과 동시에 수신처 측이 데이터 전송 허가요청을 함께 보냄</li>\n<li>송신처도 데이터 전송 허가를 보내면서 상방향의 통로를 확보</li>\n<li>위의 과정을 3way handshake라고 한다.</li>\n<li>\n<p>커넥션을 끊기 위해 4way handshake를 한다.</p>\n<ul>\n<li>중간에 wait하는 시간이 있는데, 아직 상대방은 끊은지 모르고 보낼 수 있기 때문에 wait이 존재한다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>TCP는 어플리케이션으로 부터 받은 데이터를 세그먼트로 캡슐화한다.</p>\n<ul>\n<li>캡슐화 할 때 한개의 데이터를 MSS(Max Segment Size)로 분할</li>\n<li>각각의 세그먼트에 번호를 부여하고, 이 번호를 시퀀스 번호라고 한다.</li>\n</ul>\n</li>\n<li>RTT(Round Trip Time) : 지금까지 보낸 데이터에 대해 확인응답이 돌아오기 까지 걸린 시간을 계산함.</li>\n<li>\n<p>윈도우 제어: 위의 방법을 쓴다면, 응답 확인이 오기 전까지는 다음 패킷을 전송하지 않는데 그러면 효율이 좋지 못하다. 그래서 한번에 패킷을 여러개 보내는 방법을 사용하는데, 이곳에서 윈도우 제어를 사용한다. 버퍼를 사용하여 해당 버퍼의 양이 다 전송완료 되면 다음 패킷들을 보낸다. 또 어느정도 버퍼량을 갖는지 서로 공유하여 윈도우 사이즈만큼 데이터를 보내 오버플로 하지 않는다. 확인응답을 기다리지 않고 보낼 수 있는 데이터을 윈도우사이라고 할 수 잇다.</p>\n<ul>\n<li>윈도우 사이즈로 상대방에게 자신의 버퍼량을 전달해서 수신할 수 있는 용량을 조절한다.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>UDP</li>\n</ul>\n</li>\n<li>\n<p>포트번호</p>\n<ul>\n<li>port number : 어플리케이션이 송신한 데이터인지 어느 어플리케이션이 수신한 데이터 인지 결정하기 위한것.</li>\n<li>well known port : 1 ~ 1023번 까지 이미 정해져 있는 잘 알려진 포트넘버</li>\n</ul>\n</li>\n<li>\n<p>UDP</p>\n<ul>\n<li>커넥션을 맺지 않고, TCP와 다르게 정확 확실하지 않지만 빠르다는 장점이 있다.</li>\n<li>브로드캐스트가 필요한 어플리케이션도 UDP를 사용할 수 있다. 호스트의 비트 번호가 모두 1인 주소로 하면 브로드캐스트를 할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>네트워크 주소 변환</p>\n<ul>\n<li>네트워크 고갈 문제를 해결하기 위한 방법</li>\n<li>\n<p>인터넷에 접속하지 않는 네트워크를 위해 사용할 수 있는 IP 주소</p>\n<ol>\n<li>Class A : 10.0.0.0</li>\n<li>Class B : 172.16.0.0 ~ 172.31.0.0</li>\n<li>Class C : 192.168.0.0 ~ 192.168.255.0</li>\n<li>인터넷에 접속하지 않고 TCP/IP를 사용할 경우 위의 주소를 사용해도 되고, 중복을 염려하지 않아도 된다.</li>\n</ol>\n</li>\n<li>\n<p>NAT(Network Address Translation)</p>\n<ul>\n<li>내부 네트워크에서는 사설 IP를 할당하는데 이는 내부 네트워크에서 TCP/IP를 사용한 통신을 위한것이다.</li>\n<li>인터넷을 이용할 때는 글로벌 IP 주소로 다시 바꿔서 내보낸다.</li>\n<li>하지만 NAT가 보유하는 글로벌 IP주소 수 이상의 호스트는 인터넷에 동시에 접속할 수 없다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>NAPT(Network Address Port Translation)</p>\n<ul>\n<li>하나의 글로벌 IP주소로 복수의 컴퓨터를 접속하게 하는데 IP 주소 뿐만 아니라 포트 번호도 변환해서 IP보다 더 많은 컴퓨터 접속을 가능하게 한다.</li>\n<li>단점으론 LAN 내부에서 외부로 공개하고 싶은 서버가 있을 경우 NAPT 테이블에 저장되있지 않는 것은 LAN 내부로 들어올 수 없다.</li>\n<li>해결책으로 수동으로 변환을 입력하여 NAPT테이블에 미리 변환을 저장 시켜줘야 한다.</li>\n<li>또 다른 단점으로 FTP를 기본으로 지원하지 않는다. FTP 데이터 부분에도 송신처의 IP 주소와 포트 번호가 기술되는데, 이것은 NAPT의 관리 대상이 되지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>5 ~ 7계층</p>\n<ul>\n<li>5계층 : 세션 계층으로 다이얼로그 제어를 하며 간단하게 말하면 대화가 성립되도록 하는 제어이다.</li>\n<li>6계층 : 표현 계층으로 어플리케이션에 맞는 데이터 형식(문자, 영상, 동영상, 음성)이 있는데 변환을 해서 하드웨어랑 OS 차이를 없앤 데이터를 교환한다. 압축이나 암호화를 수행할 수도 있다.</li>\n<li>7계층 : 어플리케이션 계층으로 어플리케이션의 목적에 따라 네트워크 서비스를 제공하는 계층이다. 어플리케이션 계층이 각각 목적에 따라 송수신하는 데이터의 형식이나 순서 등이 정해져 있다.</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"하루 3분 네트워크 스터디 5","date":"March 03, 2020"}}},"pageContext":{"slug":"/study/하루3분 네트워크5/","previous":{"fields":{"slug":"/til/2020-02-30/"},"frontmatter":{"title":"2020-02-30 TIL","category":"TIL"}},"next":{"fields":{"slug":"/study/하루3분 네트워크3/"},"frontmatter":{"title":"하루 3분 네트워크 스터디 3","category":"study"}}}},"staticQueryHashes":["3128451518","96099027"]}