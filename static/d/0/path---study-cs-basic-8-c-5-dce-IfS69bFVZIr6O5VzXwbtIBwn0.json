{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"ed2cade5-b89f-5a44-8e61-5c0954989482","excerpt":"정수의 표현 자바에서는 int를 4byte로 표현한다. 32bit 중에 가장 높은 자리수의 비트는 sign bit로 사용된다. 0이면 양수 1이면 음수. signed 정수의 범위는 -2147483648 ~ 2147483647 이다. 양의 정수는 0x00000001 ~ 0x7fffffff(2147483647) 까지이다. 음의 정수는 0xffffffff(-1) ~ 0x80000000(-2147483648) 까지이다. -1을 16진수로 표현하기 위해선 0x00000001(1)에…","html":"<h2 id=\"정수의-표현\"><a href=\"#%EC%A0%95%EC%88%98%EC%9D%98-%ED%91%9C%ED%98%84\" aria-label=\"정수의 표현 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정수의 표현</h2>\n<ul>\n<li>\n<p>자바에서는 int를 4byte로 표현한다.</p>\n</li>\n<li>\n<p>32bit 중에 가장 높은 자리수의 비트는 sign bit로 사용된다. 0이면 양수 1이면 음수.</p>\n</li>\n<li>\n<p>signed 정수의 범위는 -2147483648 ~ 2147483647 이다.</p>\n</li>\n<li>\n<p>양의 정수는 0x00000001 ~ 0x7fffffff(2147483647) 까지이다.</p>\n</li>\n<li>\n<p>음의 정수는 0xffffffff(-1) ~ 0x80000000(-2147483648) 까지이다.</p>\n<ul>\n<li>-1을 16진수로 표현하기 위해선 0x00000001(1)에 2의 보수를 취해주면 0xffffffff이다.</li>\n<li>-2을 16진수로 표현하기 위해선  0x00000002(2)에 2의 보수를 취해주면 0xfffffffe이다.(-2 이다.)</li>\n<li>이것으로 볼때 음수는 0xffffffff부터 시작해서 1씩 빠지면서 감소한다.</li>\n<li>그렇기 때문에 0x80000001은 -2147483647의 결과값이 나온다.</li>\n</ul>\n</li>\n<li>\n<p>0을 기준으로 표현한다면 0x80000000(-2147483648) ~ 0xffffffff(-1) ~ 0 ~ 0x00000001 ~ 0x7fffffff(2147483647) 이다.</p>\n</li>\n<li>\n<p>Integer.compareUnsigned(int a, int b)의 내부를 살펴보면 Integer의 최솟값(-2147483648 = 0x80000000)을 a와 b에 각각 더해서 compare 함수를 실행한다.</p>\n<ul>\n<li>위의 함수는 unsigned된 int만을 사용해서 비교하는 값이다.</li>\n<li>a는 -1을 b는 2를 입력해보자. 이 결과에선 -1이 나와야 하는 상황이다. ( a &#x3C; b -> -1),(a > b -> 1), (a = b -> 0)</li>\n<li>그래서 음수를 입력할 경우에 -2147483648(0x80000000) + (- 1)이 되고 계산해보면 a = 0x7ffffffff(2147483647)이 된다.</li>\n<li>다음으로 그리고 다음 파라미터에는 +2를 넣어보면 0x80000000(-2147483648) + 2가 될것이고, 결과값은 b = 0x80000002(-2147483646)이 될것이다.</li>\n<li>결과값을 보면 a > b의 결과가 나오므로 1이 리턴이 되는 상황이 발생한다.</li>\n<li>이런 문제가 발생하기 때문에 반드시 signed가 아닌 unsigned 이 함수를 이용하여 정상적인 동작을 기대하기 위해선integer의 값만 넣어야한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"양의-정수는-최대값-0x7fffffff-까지-양수이다가-1을-하면서-0x80000000-2147483648-쵯소값으로-변환한다\"><a href=\"#%EC%96%91%EC%9D%98-%EC%A0%95%EC%88%98%EB%8A%94-%EC%B5%9C%EB%8C%80%EA%B0%92-0x7fffffff-%EA%B9%8C%EC%A7%80-%EC%96%91%EC%88%98%EC%9D%B4%EB%8B%A4%EA%B0%80-1%EC%9D%84-%ED%95%98%EB%A9%B4%EC%84%9C-0x80000000-2147483648-%EC%B5%AF%EC%86%8C%EA%B0%92%EC%9C%BC%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%9C%EB%8B%A4\" aria-label=\"양의 정수는 최대값 0x7fffffff 까지 양수이다가 1을 하면서 0x80000000 2147483648 쵯소값으로 변환한다 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>양의 정수는 최대값 0x7fffffff 까지 양수이다가 +1을 하면서 0x80000000(-2147483648) 쵯소값으로 변환한다</h3>\n<h2 id=\"1의-보수\"><a href=\"#1%EC%9D%98-%EB%B3%B4%EC%88%98\" aria-label=\"1의 보수 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1의 보수</h2>\n<p>이진수의 모든 자리의 숫자를 반전 시키면 1의 보수를 얻을 수 있다.\n1의 보수는 대부분의 산술연산에서 원래 숫자의 음수처럼 취급된다.</p>\n<p>00010011 - 11111100 =  00010000 이라면\n값을 구하기 위해 뺄 값 (11111100) 에 1의 보수를 취하여 더해준다.\n11111100 -> 00000011 이 된다.</p>\n<p>0010011 + 0000011 = 1 00001111 의 값이 나오며, 한자릿수가 더 길어졌다.\n그런 경우엔 마지막에 1을 더한 값이 결과값이다.\n00001111 + 00000001 = 00010000 의 값이 된다.</p>\n<p>하지만 부호 전환은 2의 보수보다 쉽지만, 덧셈과 뺄셈은 더 어렵다.</p>\n<h2 id=\"2의-보수\"><a href=\"#2%EC%9D%98-%EB%B3%B4%EC%88%98\" aria-label=\"2의 보수 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2의 보수</h2>\n<p>이진수의 모든 자리의 숫자를 반전 시킨 뒤 여기에 1을 더하면 2의 보수를 얻을 수 있다.\n2의 보수는 대부분의 산술연산에서 원래 숫자의 음수처럼 취급된다.</p>\n<p>01001011 의 모든 자리의 수를 반전시킨다.</p>\n<p>10110100 (이것을 1의 보수라고 부른다)</p>\n<p>여기에 1을 더한다.\n10110100(180) + 00000001(1) = 10110101(181)</p>\n<p>그러면 100-75 의 값을 구해보자.</p>\n<p>100 -> 01100100\n75 -> 01001011 (2의 보수로 변경) -> 10110100 + 00000001 = 10110101</p>\n<p>01100100 + 10110101 = 1 00011001 의 결과가 나온다.\n결과값은 00011001이다.</p>\n<p>2의 보수를 사용한 연산에서 가장 높은 자리에서 자리올림이 발생하면 무시한다.\n그렇기 때문에 1의 보수 보다 계산이 빠르다</p>","frontmatter":{"title":"CS 기초","date":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/study/CS Basic/","previous":{"fields":{"slug":"/study/Array & List/"},"frontmatter":{"title":"Array와 List","category":"study"}},"next":{"fields":{"slug":"/study/asSequence/"},"frontmatter":{"title":"Kotlin의 asSequence","category":"kotlin"}}}}