{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/2021-03-05/","result":{"data":{"site":{"siteMetadata":{"title":"Zero1's Note","author":"Zero1","siteUrl":"https://github.com/2Zero1","comment":{"disqusShortName":"2Zero1","utterances":"2Zero1 Blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"bef7ea04-a91f-5edb-98a9-92d6922128f0","excerpt":"fact 코드숨 6장 지역 서버로 부터 데이터 받아서 보여지도록 구현 tdd 사이클로 진행 카테고리 구현 이력서 업데이트 dom을 깨우치다 책 읽고 쳐보기 feelings 뭔가 금요일이라 힘들었다. finding 코드숨 6장 reactRouter의 url/:value 형식으로 properties를 넘겨주는것을 알게되었다. DOM을 깨우치다 (22p~40p) classList..contains() 메서드를 이용하면, class attribute…","html":"<ol>\n<li>\n<p>fact</p>\n<ul>\n<li>코드숨 6장 지역 서버로 부터 데이터 받아서 보여지도록 구현</li>\n<li>tdd 사이클로 진행</li>\n<li>카테고리 구현</li>\n<li>이력서 업데이트</li>\n<li>dom을 깨우치다 책 읽고 쳐보기</li>\n</ul>\n</li>\n<li>\n<p>feelings</p>\n<ul>\n<li>뭔가 금요일이라 힘들었다.</li>\n</ul>\n</li>\n<li>\n<p>finding</p>\n<ul>\n<li>\n<p>코드숨 6장</p>\n<ul>\n<li>reactRouter의 url/:value 형식으로 properties를 넘겨주는것을 알게되었다.</li>\n</ul>\n</li>\n<li>DOM을 깨우치다 (22p~40p)</li>\n<li>\n<p>classList..contains() 메서드를 이용하면, class attribute 값이 특정 하위 값을 가지고 있는지를 판별(boolean)할 수 있다.</p>\n<ul>\n<li>element.classList.contains(‘div’)</li>\n</ul>\n</li>\n<li>\n<p>element 노드의 dataset 속성은 element에서 data-* 로 시작하는 모든 attribute를 가진 개체를 제공해준다. 이는 js 객체이므로, dataset을 조작해서 DOM 내의 element에 변경 내용을 반영할 수 있다.</p>\n<ul>\n<li>\n<div data-foo-foo=\"foo\"></div>\n</li>\n<li>element.dataset.fooFoo</li>\n<li>dataset은 data attribute들의 camelCase 버전을 갖는다.</li>\n<li>DOM 에서 data-* attribute를 제거하려면, delete연산자를 사용한다.(delete dataset.fooFoo)</li>\n</ul>\n</li>\n<li>\n<p>단일 element 노드에 대한 참조를 얻는 데 가장 흔히 사용되는 메서드</p>\n<ul>\n<li>\n<p>querySelector()</p>\n<ul>\n<li>css3 selectorr를 전달하면(예 #score>tbody>tr>td:n th-of-type(2)), DOM에서 단일 element를 선택하는 데 사용된다.</li>\n</ul>\n</li>\n<li>getElementById()</li>\n</ul>\n</li>\n<li>\n<p>HTML 문서 내의 노드 리스트(NodeList)를 선택 및 생성하는 데 가장 흔히 사용되는 메서드들이다.</p>\n<ul>\n<li>querySelectAll()</li>\n<li>getElementByTagName()</li>\n<li>getElementByClassName()\ngetElementsByTagName()과 getElementsByClassName()으로 생성된 NodeList는 라이브 상태로 깐주되며, 리스트를 생성하고 선택한 후에 문서가 업데이트 된 경우에도 문서의 상태를 항상 반영한다.</li>\n<li>querySelectorAll() 메서드는 라이브 상태의 element 리스트를 반환하지 않고 리스트 생성 시점의 문서 스냅샷이다. 문서의 변경 내용을 반영하지 않는다는 것을 의미한다.</li>\n<li>getElementByName은 문서 내에 동일한 name attribute 값을 가진 form, img, frame, embed, object element를 선택할 때는 이 메서드가 있다는 것을 알아둘 필요가 있다.</li>\n<li>childNodes도 querySelectorAll(), getElementsByTagName(), getElementsByClassName() 처럼 NodeList를 반환한다.</li>\n<li>NodeList는 유사 배열 리스트/컬렉션이며, 읽기 전용인 length 속성(array의 메서드를 상속 받은것은 아니다)을 가진다.</li>\n</ul>\n</li>\n<li>\n<p>element 노드에서 children 속성을 사용하면, element 노드의 직계 자식 노드 전체 리스트(HTMLCollection)를 얻을 수 있다.</p>\n<ul>\n<li>children은 직계 element 노드만을 제공하며, element가 아닌 노드(예 text노드)는 제외된다</li>\n<li>자식이 없는 경우 children은 빈 유사배열을 반환한다.</li>\n<li>HTMLCollection은 element를 문서 내의 순서대로 가져온다.</li>\n<li>HTMLCollection은 라이브 상태다.</li>\n</ul>\n</li>\n<li>\n<p>document 개체를 통해 접근되는 querySelector(), querySelectorAll(), getElementByTagName(), getElementsByBlassName()은 element 노드에도 정의된다. 이는 해당 메서드의 결과가 DOM 트리의 특정 부분(혹은 일련의 부분들)으로 제한할 수 있게 해준다. 달리말해, element 노드 개체에서 이 메서드를 호출하면, element 노드를 검색하고자 하는 특정 컨텍스트를 선택할 수 있다는 것이다.</p>\n<ul>\n<li>위의 메서드들은 라이브 상태의 DOM 에서만 동작하는 것이 아니라 코드로 생성한 DOM 구조에서도 동작한다.(createElement)</li>\n</ul>\n</li>\n<li>\n<p>HTML 문서에서 element 노드를 포함하고 있는 사전 구성된 유사 배열 리스트각 몇 개 존재한다.</p>\n<ul>\n<li>document.all</li>\n<li>document.forms</li>\n<li>document.images</li>\n<li>document.links : 문서 내의 모든 <a> element</li>\n<li>document.scripts : 문서 내의 모든 <script> element</li>\n<li>styleSheets : 문서 내의 모든 <link> 또는 <style> element</li>\n<li>앞의 사전에 구성된 배열들은 HTMLCollection 인터페이스/개체를 통해 생성되는데 document.styleSheets만 예외적으로 StyleSheetList를 사용한다.</li>\n</ul>\n</li>\n<li>\n<p>matchesSelector() 메서드를 사용하면, element가 selector 문자열에 들어맞는지를 판별할 수 있다.</p>\n<ul>\n<li>\n<li>hello</li>\n</li>\n<li>document.querySelector(‘li’).matchesSelector(‘li:first-child’)</li>\n</ul>\n</li>\n<li>5장</li>\n<li>\n<p>HTML 문서를 웹 브라우저에 볼 때, DOM 노드가 해석되어 시각적인 모양으로 그려진다. 노드 (대부분 element 노드)는 브라우저에서 볼 수 있는 시각적인 표현 형태를 가지기 위해 일련의 API들이 존재한다.</p>\n<ul>\n<li>element 노드의 지오메트리(크기 및 오프셋을 사용한 위치)를 측정하는것 뿐만 아니라, 스크롤이 가능한 노드를 조작하기 위해 가로채고, 스크롤된 노드의 값을 가져오기 위한 API도 제공한다.</li>\n<li>CSSOM View Vodule 사양에 있는 대부분의 속성(scrollLeft와 scrollTop은 제외)은 읽기 전용이며 접근시마다 매번 계산된다. 즉 이값들은 라이브 상태다.</li>\n</ul>\n</li>\n<li>offsetTop 및 offSetLeft 속성을 사용하면, offsettParent로 부터 element 노드의 오프셋 픽셀 값을 가져올 수 있다. 이 element 노드 속성들은 element의 바깥쪽 좌상단 경계로부터 offsetParent의 안쪽 좌상단 경계까지의 거리를 픽셀로 제공해준다. offsetParent의 값은 가장 가까운 부모 element 중에서 css 위치 값이 static이 아닌 elementt를 검색하여 결정된다. 아무 element도 발견되지 않으면, offsetParent의 값은 <body> element나 ‘document’에 해당하는 것(브라우저의 view port와는 다름)이 된다. 부모를 탐색하는 동안 css위치 값이 static인 <td>, <th>, <table> element가 발견되면 이 element가 offsetParent가 된다.</li>\n<li>getBoundingClientRect() 메서드를 사용하면, viewport의 좌상단 끝을 기준으로 element가 브라우저에서 그려질 때 element의 바깥쪽 테두리 위치를 얻을 수 있다. left및 right는 element의 바깥쪽 테두리로부터 뷰 포트의 왼쪽 끝까지 측정되며, top과 bottom은 element의 바깥쪽 테두리로부터 뷰포트의 상단까지 측정된다.</li>\n<li>\n<p>getBBoundingClient()는 height와 width 속성 값도 가지고 있는 객체를 반환한다.. 이는 element의 크기를 가리키며, 전체 크기는 div의 내용, 패딩, 테두리를 모두 더한 것이다.</p>\n<ul>\n<li>document.querySelector(‘div’).getBoundingClientRect().height or width</li>\n<li>\n<p>offsetHeight와 offsetSetWidth 속성을 사용해도 동일한 크기를 얻을 수 있다.</p>\n<ul>\n<li>document.querySelector(‘div’).offsetHeight or width</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Future Action Plan</p>\n<ul>\n<li>나한태 위로와 칭찬을 한다.</li>\n<li>너무 무리하지 말자</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"2021-03-05 TIL","date":"March 05, 2021"}}},"pageContext":{"slug":"/til/2021-03-05/","previous":{"fields":{"slug":"/til/2021-03-04/"},"frontmatter":{"title":"2021-03-04 TIL","category":"TIL"}},"next":{"fields":{"slug":"/study/하루3분 네트워크5/"},"frontmatter":{"title":"하루 3분 네트워크 스터디 5","category":"study"}}}},"staticQueryHashes":["3128451518","96099027"]}